\documentclass[
a4paper, 							% Papierformat
%10pt,								% Schriftgröße (12pt, 11pt (Standard))
%twoside,							% Doppelseiten
titlepage,						% Titelei auf eigener Seite
normalheadings,				% Überschriften etwas kleiner (smallheadings)
%idxtotoc,						% Index im Inhaltsverzeichnis
%liststotoc,					% Abb.- und Tab.verzeichnis im Inhalt
%bibtotoc,						% Literaturverzeichnis im Inhalt
%leqno,   						% Nummerierung von Gleichungen links
%fleqn,								% Ausgabe von Gleichungen linksbündig
%draft								% überlangen Zeilen in Ausgabe gekennzeichnet
]
{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[isolatin]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm,includeheadfoot]{geometry}

\begin{document}

\thispagestyle{empty}
\begin{titlepage}
\begin{figure}[t]
	\centering
  \includegraphics[width=80mm]{HsKaLogoKlein.png}
	\vspace{2.5cm}
\end{figure}
\begin{center}
\title{Spec Explorer - A Model-Based Testing tool from Microsoft}
\textbf{\huge{Spec Explorer}} \\[0.5cm]
\textbf{A Model-Based Testing tool from Microsoft} \\[4cm]
\textbf{Seminararbeit} \\[0.25cm]
\author{Manuel Naujoks} Manuel Naujoks\\[2.5cm]
Betreut durch \\[0.25cm] 
Prof. Dr. Thomas Fuchß \\[2.5cm]
Bischweier, den \today
\end{center}
\end{titlepage}



\thispagestyle{empty}
\begin{center}\textbf{\large Erklärung}\\[1cm]\end{center}
Hiermit versichere ich, dass ich die vorliegende Arbeit selbstständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, dass alle Stellen der Arbeit, die wörtlich oder sinngemäß aus anderen Quellen übernommen wurden, als solche kenntlich gemacht sind und dass die Arbeit in gleicher oder ähnlicher Form noch keiner Prüfungsbehörde vorgelegt wurde.
\\[4\baselineskip]
Bischweier, den \today \\
Manuel Naujoks



\begingroup
\addtocontents{toc}{\protect\thispagestyle{empty}}
\pagestyle{empty}
\tableofcontents
\newpage
\setcounter{page}{1}
\endgroup



\chapter{Einführung}
\label{chap:einfuehrung}
In dieser Seminararbeit soll das Programm Spec Explorer vorgestellt werden. Dabei handelt es sich um eine Anwendung die modellbasiertes Testen unterstützt. Spec Explorer ist seit 2010 ein Visual Studio Power Tool \cite{DuWors2010} und integriert sich als Erweiterung in die Entwicklungsumgebung von Microsoft ab Version 2010 Professional. Über die Visual Studio Gallery kann das Tool installiert werden \cite{Microsoft2010}.
\\\\
Traditionelles Testen von Software wird oft manuell vorgenommen. Das bedeutet das ein Mensch das Programm bedient und sämtliche Szenarien und Testfälle ausprobiert und mit einem erwarteten Ergebnis vergleicht. Da Software im Laufe der Zeit immer komplexer geworden ist und die realisierten Szenarien pro Anwendung zugenommen haben, wurden Tests zunehmend automatisiert. Testfälle müssen so nur noch einmal spezifiziert werden und können dann automatisiert durchgeführt werden. Diese Automatisierung erlaubt ein wesentlich effizienteres Testen und reduziert das menschliche Fehlerpotenzial.
\\
Ein Softwaresystem kann auf verschiedenen Ebenen getestet werden. Bisher wurde der Begriff des Testen verallgemeinert verwendet. Eine Ebene für Tests stellt die komplette Anwendung dar, in der Szenarien wie von einem Nutzer ausgeführt getestet werden können. Eine weitere Ebene ist eine logisch zusammengehörende Einheit von Programmcode (Unit). Hier werden die einzelnen Bausteine des komplexen Systems isoliert voneinander getestet. Eine dritte Ebene fast mehrere isolierte Bausteine zusammen und testet deren Zusammenarbeit als Szenario.
\\
Testfälle der ersten Ebene werden meistens von den Benutzern des Systems definiert, um die allgemeine Funktionsfähigkeit festzustellen. Tests der zweiten Ebene werden meistens nur von Entwicklern definiert um die Korrektheit des Programmcode sicherzustellen. Tests der dritten Ebene werden meistens von Entwicklern, Projektleitern und Benutzern definiert.
\\\\
Nachdem unterschiedliche Arten des Testen kurz vorgestellt wurden bleibt bei jeder Art eine Schwierigkeit. Testfälle müssen definiert werden und zwar so, dass sie die Anwendung möglichst ausführlich getestet wird. Bei zunehmender Komplexität der Anwendung und zunehmender Agilität der Anwendungsentwicklung stellt dies eine Herausforderung für Entwickler dar, da diese nicht nur den Programmcode, sondern auch den Testcode schreiben müssen. Spec Explorer ist ein Werkzeug das Entwickler bei der Testfallerzeugung und Lösung dieses Problems unterstützen kann.
\\
Was als wissenschaftliche Disziplin \cite{Gurevich1993} begann, findet mit Tools wie Spec Explorer Einzug in die Softwareentwicklung. Die zu testende Anwendung wird zunächst in einer abstrakten Form modelliert. Aus diesem Modell lassen sich anschließend Testfälle erzeugen, die auf den Programmcode der Anwendung angewendet werden können und die Anwendung so anhand des Modells validieren.



\chapter{Abstract State Machines}
\label{chap:asm}
Ein Computerprogramm ist ein Folge von Anweisungen die sequentiell ausgeführt werden. Eine solche Anweisung entspricht einer Zustandsänderung des Programms. Die Menge aller Zustandsänderungen repräsentiert die Funktionsweise des Systems. Yuri Gurevich hat 1999 \cite{Gurevich1999} gezeigt, dass ein solches System in einer von ihm erdachten Struktur namens \textit{Abstract State Machine} abgebildet werden kann. Laut ihm kann jeder Algorithmus, egal wie abstrakt, so modelliert werden. Eine \textit{Abstract State Machine}, 1993 unter der Bezeichnung \textit{Evolving Algebra} vorgestellt \cite{Gurevich1993}, ist ein Zustandsautomat, der Zustände nicht als explizite Dinge betrachtet. Laut Gurevich sind Zustände ambient im System vorhanden und entstehen implizit durch Veränderung von veränderlichen Eigenschaften des Systems. Auch die Zustände in einem Computerprogramm sind abstrakt und werden durch die Anweisungen des Programms verändert. Die gleichen Zustandsänderungen können durch von Gurevich als update-Anweisungen bezeichnete Ausdrücke vorgenommen werden. Gurevich's \textit{Abstract State Machine} kann damit wie in der Abbildung \ref{fig:asmschema} als eine Folge von update-Anweisungen dargestellt werden, die jeweils von einer guard-Annweisung begleitet werden. Die guard-Anweisung vergleicht den Zustand des Systems mit einem Erwartungswert und führt bei einer Übereinstimmung die zugehörige update-Anweisung aus. Die \textit{Abstract State Machine} läuft die Folge immer wieder durch und stellt somit das Programm der Zustandsmaschine dar. Endzustände, Abbruchbedingungen und andere Notationen können ebenfalls definiert werden.

\begin{figure}[htbp]
\centering
\includegraphics[height=120px]{asmschema.png}
\caption{Schematische Darstellung einer \textit{Abstract State Machine}}
\label{fig:asmschema}
\end{figure}

Das Konzept der \textit{Abstract State Machine} wird auch durch Egon Börger in Form eines Tutorials \cite{Boerger} zusammengefasst. Ihm zufolge entspricht der aktuelle Zustand im System der aktuellen konkreten Ausprägung aller Variablen in diesem System. Die Menge aller Zustände ist somit durch die Wertebereiche aller Variablen im System definiert. Zusammen mit Robert Stärk hat Egon Börger 2003 seine Abhandlungen in dem sogenannten \textit{AsmBook} zusammengefasst \cite{EgonBoerger2003}.



\chapter{Entwicklung von Spec Explorer}
Nachdem der Begriff des Testen in Kapitel \ref{chap:einfuehrung} eingeführt und das Konzept von abstrakten Zuständen in Kapitel \ref{chap:asm} erläutert wurde, beschäftigt sich dieses Kapitel mit dem Werdegang der Visual Studio Erweiterung Spec Explorer. Wolfgang Grieskamp beschreibt in seinem Blogeintrag \cite{Grieskamp2009} die Entwicklung von der theoretischen Idee der \textit{Abstract State Machine} bis zu einem allgemeinen Programm das von Entwicklern genutzt werden kann.

\section{AsmL}
Nachdem Gurevich 1999 die theoretische Grundlage gelegt \cite{Gurevich1999} hat, wurde die erste Implementierung einer Beschreibungssprache für \textit{Abstract State Machines} von einem Team in Microsoft vorgenommen. Diese Sprache wurde unter der Bezeichnung \textit{AsmL} (Abstract State Machine Language) bekannt. Laut Grieskamp \cite{Grieskamp2009} waren neben ihm selbst auch Yuri Gurevich, Margus Veanes, Wolfram Schulte, Lev Nachmanson, Colin Campbell und Nikolai Tillmann an der Entwicklung der Sprache beteiligt. Das Projekt wurde nie vollständig released und war eher ein Forschungsprojekt. \textit{AsmL} wurde nicht zum Testen, wie in Kapitel \ref{chap:einfuehrung} vorgestellt, entwickelt, sondern diente dem formalen Beweisen der Korrektheit von Softwaresystemen. Auf der Codeplex-Seite von \textit{AsmL} \cite{Microsoft2003} kann der Quellcode eines Binärcompilers heruntergeladen werden.

\section{AsmL-T}
Ein erster Ansatz \textit{AsmL} zum Testen von Softwaresystemen zu verwenden, wurde mit einer Erweiterung der Sprache unter dem Namen \textit{AsmL-T} von Wolfgang Grieskamp und Nikolai Tillmann entwickelt \cite{Grieskamp2009}. Eine wesentliche Ergänzung war die Funktion sämtliche Zustände des mit einer \textit{Abstract State Machine} beschriebenen Softwaresystems explorativ zu ermitteln. Grieskamp nennt dieses Feature \textit{state space exploration}. Damit war das erste modellbasierte Test-Werkzeug entwickelt.
\\
\textit{AsmL-T} wurde laut Grieskamp \cite{Grieskamp2009} verwendet, um die \textit{WCF} (Windows Communication Foundation) Implementierung zu testen. Angeblich wurde das Testen mithilfe von \textit{AsmL-T} beliebter und bekannter als die \textit{AsmL}-Sprache selber.

\section{Spec$\#$}
Aufgrund des zunehmendem Desinteresse an \textit{AsmL} wurde laut Grieskamp \cite{Grieskamp2009} eine neue Implementierung benötigt. Aus diesem Grund entstand \textit{Spec$\#$} als leichtgewichtige \textit{AsmL}-Implementierung. \textit{Spec$\#$} nutzt die Syntax von C$\#$ und nutzte als erste Sprache sogenannte \textit{Code Contracts}. Obwohl C$\#$-Syntax verwendet wird, wird für \textit{Spec$\#$} ein spezieller Compiler benötigt. Wahrscheinlich hat sich auch \textit{Spec$\#$} aus diesum Grund bis heute noch nicht durchgesetzt. Ob \textit{Spec$\#$} die \textit{AsmL}-Implementierung in \textit{AsmL-T} ersetzte, geht aus Grieskamps Blogpost \cite{Grieskamp2009} leider nicht hervor. 2004 wurde \textit{AsmL-T} dann Microsoft-intern unter dem Namen Spec Explorer 2004 veröffentlicht.

\section{PEX}	
Laut Grieskamp \cite{Grieskamp2009} wurde das Team, das sich bei Microsoft mit der Entwicklung von Spec Explorer 2004 beschäftigt, 2005 getrennt. Während sich ein kleiner Teil des ursprünglichen Teams weiterhin mit der Entwicklung von modellbasierten Test-Werkzeugen beschäftigt, wurde ein neues Team gegründet. Dieses neue Team entwickelte ein Programm, das zu testenden Programmcode analysiert und Eingabewerte ermittelt, die zu einer möglichst hohen Testabdeckung des zu testenden Programmcodes führen. Dieses Programm wurde inzwischen unter dem Namen \textit{PEX} veröffentlicht.



\chapter{Modellbasiertes Testen}
\label{chap:mbt}
Spec Explorer ist ein modellbasiertes Test-Werkzeug. Dieses Kapitel beschäftigt sich damit, was modellbasiertes Testen überhaupt heißt. Nico Kicillof beschreibt MBT (Model Based Testing) in seinem Blogppost \cite{Kicillof2009} als leichtgewichtige und formale Methode um ein Softwaresystem zu validieren. MBT ist formal, weil es auf einer formalen, also Maschinen leserlichen Spezifikation, also dem Modell der Software arbeitet, die getestet werden soll. Kicillof nennt eine solche Software \textit{System Under Test}. Weiterhin ist MBT leichtgewichtig, da es im Gegensatz zu anderen formalen Methoden keinen mathematischen Beweis anstrebt um zu zeigen das die Implementierung der Spezifikation unter allen möglichen Umständen entspricht. MBT erzeugt aus einem Modell systematisch eine Menge von Testfällen, die auch \textit{test suite} genannt wird. Diese Testfälle, wenn sie auf die Implementierung des Systems angewendet werden, bieten ausreichende Überzeugung, dass das \textit{System Under Test} sich so verhält, wie sein Modell es definiert hat. Laut Kicillof \cite{Kicillof2009} ist der Unterschied zwischen leichtgewichtigen und schwergewichtigen formalen Methoden der Unterschied zwischen ausreichender Überzeugung und vollständiger Sicherheit. Allerdings sei der Preis für absolute Sicherheit sehr hoch, da schwergewichtige Methoden benötigt werden, die nur sehr schwierig angewendet werden können. Der leichtgewichtige MBT-Ansatz dagegen, würde laut Kicillof, viel besser skalieren und wurde bereits erfolgreich in großen Projekten, auch innerhalb Microsoft, angewendet.

\section{Anwendung}
Nachdem die theoretischen Grundlagen des modellbasierten Testen erwähnt wurden, beschäftigt sich dieser Abschnitt mit der Anwendung der Methode. Neben vielen Texten im Internet gibt es ein Schriftstück, das besondere Authorität genießt. Margus Veanes, Colin Campbell und Wolfram Schulte haben das Spec Explorer Team bei Microsoft verlassen und zusammen mit Jonathan Jacky ein Buch über modellbasiertes Testen mit C$\#$ veröffentlicht \cite{JonathanJacky2008}. Zu diesem Buch haben besagt vier eine open-source Implementierung eines modellbasierten Test-Werkzeugs namens \textit{NModel} released \cite{Microsoft2008}, welches auf der codeplex-Seite kostenlos heruntergeladen kann. Inwiefern \textit{NModel} die gleichen Funktionen wie Spec Explorer besitzt, konnte im Rahmen dieser Seminararbeit leider nicht näher untersucht werden.

\section{Schwierigkeiten}
\label{sec:schwierigkeiten}
Obwohl die Methode des modellbasierten Testen laut Nico Kicillof \cite{Kicillof2009} wesentlich einfacher und besser anwendbar als andere Verifikationsverfahren sind, bestehen auch hier einige Schwierigkeiten. Wolfgang Grieskamp hat sich in seinem Buch \cite{Grieskamp2006} mit diesen Problemen auseinander gesetzt. In den folgenden Unterabschnitten werden die fünf Probleme näher beschrieben, die die effektive Nutzung der Methode mithilfe eines Werkzeugs besonders schwierig oder umständlich machen.

\subsection{State Explosion}
\label{subsec:stateexplosion}
Wolfgang Grieskamp beschreibt in seinem Buch \cite{Grieskamp2006} und in seinem Blogpost \cite{Grieskamp2009} das Problem, dass in einer Anwendung sehr viele Zustände existieren als \textit{State Explosion}. Die Durchführung einer \textit{State Space Exploration}, also das ermitteln aller Zustände eines Systems, wird insofern erheblich erschwert, da signifikante Zustände einfach nicht mehr in der Fülle von unwichtigen Zuständen erkannt werden können. Weiterhin besteht die Möglichkeit einer unendlich großen Zustandsmenge im Falle der Verwendung einer Listen-artigen Datenstruktur. Eine Operation, die auf einer Liste ausgeführt werden kann, hat für jede Konfiguration der Liste einen Zustand als Vorbedingung. Wenn eine Liste theoretisch unendlich viele Elemente enthalten kann, existieren unendlich viele Vorbedingungen. Ähnlich ist das wenn Objekte dynamisch instantiiert werden. Für jedes neue Objekt existiert eine neue Vorbedingung für jede globale Operation. Dieses Phänomen beschreibt Grieskamp als \textit{State Explosion}, da die Menge der Zustände sprichwörtlich explodiert, also unkontrollierbar groß wird.

\subsection{Spezifikation}
\label{subsec:spezifikation}
Ein weiteres von Wolfgang Grieskamp beschriebenes \cite{Grieskamp2006} Problem besteht in der Art und Weise wie ein Modell spezifiziert wird. In \textit{AsmL-T} wurde ein Modell in \textit{AsmL} spezifiziert und erforderte somit die Kenntnis der Sprache. Für Wissenschaftler ist dies kein Problem, für die Industrie schon. Da ein Modell eine Realität besonders einfach und abstrahiert repräsentieren soll, sollte dieses Modell auch ohne großen Aufwand erstellt werden können. Die Schwierigkeit der Modellerzeugung sollte in der Formalisierung der Anforderungen liegen und nicht in der technischen Übersetzung der Anforderung in eine spezielle Sprache. Je einfacher eine solche Sprache nutzbar ist, desto unwahrscheinlicher ist die Einführung von Fehlern bei der Formalisierung der Anforderungen.

\subsection{Zustände und Szenarien}
\label{subsec:zustaendeszenarien}
In Unterabschnitt \ref{subsec:stateexplosion} wurde die Menge an ermittelten Zuständen bereits erwähnt. Da Zustände in Unterschiedlichen Kontexten auftreten können, ist eine Abstraktion von diesen Zuständen erforderlich, um die Funktion der Implementierung den Zuständen zuordnen zu können. Wolfgang Grieskamp beschreibt \cite{Grieskamp2006} eine Lösung dieses Problem als Szenario-Orientierung. Ein Szenario ist ein Ablauf von verschiedenen Funktionen des Systems. Das System erreicht darin mehrere Zustände in einer Reihenfolge. Ein Beispiel für ein Szenario wäre: Benutzer meldet sich am System an, macht etwas und meldet sich wieder ab. Szenarien können daher auch \textit{User Stories} genannt werden. Laut Grieskamp \cite{Grieskamp2009} unterstützen viele MBT-Werkzeuge nur das Testen der der Zustände der Implementierung, nicht aber das Testen von Szenarien. Er sieht eine Schwierigkeit in der Kombination des Zustandsraums (State Space), der durch die \textit{State Space Exploration} generiert wird, mit den Aktions-orientierten Szenariobeschreibungen. Während \textit{Unit Tests}, wie sie in Kapitel \ref{chap:einfuehrung} beschrieben wurden, Szenarien testen, sollte ein MBT-Ansatz diese Szenarien ebenfalls testen können um eine vergleichbare Testgranularität gewährleisten zu können.

\subsection{IDE Unterstützung}
\label{subsec:ideunterstuezung}
Wolfgang Grieskamp identifiziert in seinem Blogpost \cite{Grieskamp2009} die mangelnde Integration in Entwicklungswerkzeuge als weiteres Problem. Viele formale Verifikationsverfahren nutzen spezielle Programm, die Wissenschaftler bedienen können, Entwickler dagegen in der Regel nicht verstehen. Wenn die Methode des modellbasierten Testen an Beliebtheit und Bekanntheit zunehmen soll, muss eine Umgebung genutzt werden, in der sich die Entwickler auskennen. Es kann allgemein als unrealistisch angesehen werden, dass ein Entwickler eine neue Umgebung erlernen wird, wenn er nur eine indirekte  Produktivitätssteigerung des sowieso unbeliebten Testen erreichen kann. Im Gegensatz ist eine Testumgebung, mit der der Entwickler bereits vertraut ist, die ideale Voraussetzung. Die zu testende Implementierung, das Modell und die Verifikation sollte laut Grieskamp über eine einheitliche Benutzerschnittstelle erreichbar sein. Da die IDE (Integrated Development Environment) bereits für die Implementierung des Systems genutzt wird, liegt eine Integration des MBT-Werkzeugs in dieses Programm nahe.

\subsection{Testfallerzeugung}
\label{subsec:testfallerzeugung}
Wenn MBT-Werkzeuge eine Implementierung anhand eines Modells verifizieren, dann sollte der Prozess der Verifikation ebenfalls von einem Test Runner durchgeführt werden können, der auch \textit{normale} Tests durchführen kann. Wolfgang Grieskamp sieht in der fehlenden Unterstützung für Test Runner ein weiteres Problem \cite{Grieskamp2009} des MBT-Ansatzes. Die Verifikation anhand eines Modells sollte  ohne hohe Laufzeitkosten durchgeführt werden können, also ohne jedes mal eine \textit{State Space Exploration} durchführen zu müssen. Besonders vor dem Hintergrund von Continuous Integration ist eine automatische Verifikation als Teil eines automatisierten Buildvorgangs durchaus denkbar. Der Schritt des Testen der Implementierung sollte laut Grieskamp so allgemein wie möglich durchgeführt werden können und zwar auf eine Weise, die dem traditionellen Testen mit \textit{Unit Tests} sehr ähnlich ist. Eine Erzeugung der Testfälle für ein bekanntes Testing Framework würde das modellbasierte Testen, zumindest was den Schritt der Verifikation angeht, erheblich erleichtern.

\chapter{Spec Explorer 2010}
Die aktuelle Version heißt Spec Explorer 2010. Ein erster Prototyp des Werkzeugs, dessen Funktionen dem heutigem Funktionsumfang annähernd entsprechen, wurde bereits 2006 veröffentlicht. Nachdem in dem vorigen Kapitel \ref{chap:mbt} die Idee des modellbasierten Testen beschrieben und auf deren Schwierigkeiten in der Anwendung eingegangen wurde, wird dieses Kapitel die Visual Studio Erweiterung Spec Explorer vorstellen. Dabei wird zunächst gezeigt, wie Spec Explorer die in Abschnitt \ref{sec:schwierigkeiten} vorgestellten Schwierigkeiten versucht zu lösen. Die Punkte, die im Folgenden als Lösungen beschrieben werden, sind aus der Evaluierung des Werkzeugs hervorgegangen.

\section{Die Lösung}
In diesem Abschnitt wird beschrieben, wie Spec Explorer die in Abschnitt \ref{sec:schwierigkeiten} beschriebenen Schwierigkeiten bei der Verwendung eines MBT-Werkzeugs adressiert.

\subsection{State Explosion}
Das in Unterabschnitt \ref{subsec:stateexplosion} beschriebene Problem, dass der Zustandsraum sehr groß wird löst Spec Explorer dadruch Abbruchgrenzen. So ist es möglich den Zustandsraum nur für eine definierte Anzahl an Interation zu explorieren. Weiterhin lassen sich auch Abbruchbedingungen als sogenannte \textit{Bounds} definieren, die Zustände ab einer definierten Entfernung vom Startzustand ignorieren. Was Konfigurationsmöglichkeiten betrifft nutzt Spec Explorer sogenannte \textit{configs} und \textit{machines}, welche in einer Konfigurationsdatei definiert werden. Diese Konfiguration wird über eine Scriptsprache zur Koordination realisiert, die \textit{CORD} genannt wird.
\\
Über \textit{configs} können Einstellungen wie beispielsweise Abbruchbedingungen für die Exploration definiert werden. Weiterhin können auch die Methoden des Modells, die für die Exploration von Bedeutung sind, mit einem Wertebereich für Parameter versehen werden um spezielle Parameterkombinationen zu erzeugen. Diese Methoden werden von Spec Explorer genutzt um das Modell zu explorieren und somit alle Zustände des Modells zu erreichen. Dabei werden die Parameterkombinationen berücksichtigt.
\\
Über \textit{machines} kann die Benutzbarkeit des Modells definiert werden. In Abschnitt \ref{sec:explorationmanager} wird der Exploration Manager vorgestellt. In diesem Manager, der die Interaktion des Benutzers mit dem Tool ermöglicht, werden alle \textit{machines} aufgelistet. Eine \textit{machine} könnte zum Beispiel die Exploration des Modells repräsentieren. Eine weitere \textit{machine} könnte den Zustandsraum mit Szenarien, die ebenfalls als \textit{machine} definiert werden können, verbinden. Auch die Testfallerzeugung wir mit einer \textit{machine} beschrieben.

\subsection{Spezifikation}
Spec Explorer löst die Schwierigkeit des in Unterabschnitt \ref{subsec:spezifikation} als Modellspezifikation beschrieben Problem auf eine sehr einfache Art. Die formale Spezifikation des Modells, das  die Implementierung repräsentieren soll, kann mithilfe der .NET Sprache C$\#$ vorgenommen. Dadurch brauch der Entwickler keine neue Syntax lernen und kann sich auf die Übersetzung von Anforderungen in ein C$\#$-Modell konzentrieren. Unterstützung für andere .NET Sprachen als Modellsprache konnte im Rahmen der Evaluierung nicht festgestellt werden. 

\subsection{Zustände und Szenarien}
\label{subsec:loesungszenarien}
In Unterabschnitt \ref{subsec:zustaendeszenarien} wurde das Problem beschrieben, dass Funktionen, wie Kapitel \ref{chap:einfuehrung} vorgestellt, als Szenarien getestet werden. Erst durch ein erfolgreich getestetes Szenario kann davon ausgegangen werden, dass ein Feature der Anwendung funktioniert. Ein Szenario ist, wie bereits erwähnt, eine Abfolge von Benutzer-Aktionen: Einloggen, Bestellen, Ausloggen wäre ein Beispiel. Spec Explorer erlaubt es, Szenarien als \textit{machines} zu definieren. Dazu wird eine \textit{CORD}-Syntax verwendet, die sehr stark an reguläre Ausdrücke erinnert, um Aktionen, die im Modell als solche gekennzeichnet werden, in definierter Reihenfolge aufzurufen. Welche Möglichkeiten diese Ausdrucksweise bietet, konnte in dieser Seminararbeit leider nicht weiter analysiert werden.
\\
Wird die \textit{machine} eines Szenarios über den Exploration Manager aufgerufen, wird das Modell anhand des Szenarios ebenfalls exploriert und als Zustandsdiagramm dargestellt. Dabei nimmt das Modell pro Aktion einen Zustandswechsel vor, sodass mehrere Zustände erreicht werden. In einer weiteren \textit{machine} können die Zustände, die durch ein Szenario erreicht werden, aus der Zustandsraum-Exploration heraus geschnitten werden. Spec Explorer spricht hier von \textit{slicing}. Das Ergebnis dieser parallelen Ausführung der Explorations-Maschine und der Szenario-Maschine kann ebenfalls als Zustandsdiagramm dargestellt werden. Hier werden dann alle Zustände angezeigt, die durch Aufrufe der Aktionen des Modells mit konkreten Werten im Rahmen eines Szenarios erreicht werden. Es entsteht also ein Zustandsautomat, der ein Szenario, also die Features einer User Story, repräsentiert. Aus dieser kombinierten \textit{machine} werden später auch die Testfälle für dieses Feature erzeugt.

\subsection{IDE Unterstützung}
In Unterabschnitt \ref{subsec:ideunterstuezung} wurde mangelnde Unterstützung für Entwicklungsumgebungen als Problem klassifiziert. Spec Explorer ist eine Visual Studio 2010 Erweiterung und damit in die IDE von Microsoft integriert. In Kapitel \ref{chap:vsintegration} wird konkret gezeigt, wie diese Integration aussieht. Unterstützung für andere Entwicklungsumgebungen ist nicht vorhanden. Da Erweiterungen für Visual Studio 2010 erst ab der Professional Edition installiert werden können, ist Spec Explorer leider auch nicht für die Visual Studio Express Editionen verfügbar.

\subsection{Testfallerzeugung}
Das Funktionen der Anwendung Szenario-orientiert getestet werden, wurde bereits in Kapitel \ref{chap:einfuehrung} erwähnt. Wie Szenarien mit Spec Explorer im Rahmen der Zustandsraum-Exploration verwendet werden können, wurde in Unterabschnitt \ref{subsec:loesungszenarien} beschrieben. Spec Explorer nutzt das standardmäßig mit Visual Studio 2010 Professional ausgelieferte Test Framework (\textit{Microsoft.VisualStudio.TestTools.UnitTesting}) sowie dessen Integration \textit{MS Test}. Damit laufen die von Spec Explorer erzeugten Testfälle im Test Runner von Visual Studio. Unterstützung für andere Test Frameworks konnte leider nicht festgestellt werden.
\\
Testfälle werden durch eine \textit{machine} erzeugt, die den Zustandsautomaten eines Szenarios in einzelne lineare Abläufe von Aktionen aufteilt. Aus einem Szenario werden so mehrere isolierte Abläufe, die in dem Automaten parallel existieren. Die erzeugten Tests sind sehr überladen und erhalten neben den Aufrufen der Aktionen der Implementierung, die durch das Modell festgelegt wurden, eine Menge an Kommentaren, die den Testfall unleserlich machen. Da die erzeugten Tests jederzeit neu aus der entsprechenden \textit{machine} erzeugt werden können, ist eine manuelle Änderung nicht vorgesehen.
\\ 
Bei der Testfallerzeugung kommt zum ersten mal die Implementierung zum Tragen. Während die Zustände und Szenarien über dem Modell definiert werden, nutzen die erzeugten Tests die Implementierung. Die Tests rufen die über Aktionen auf dem Modell definierten Methoden der Implementierung auf, und vergleichen anschließend den Zustand der Implementierung mit dem Zustand den das Modell in gleichem Kontext hatte. Der Test schließt erfolgreich ab, wenn die Implementierung der gleichen Zustand besitzt wie das Modell. Der Test schlägt fehl, wenn die Zustände nicht identisch sind. Also wird die in Kapitel \ref{chap:mbt} beschriebene Verifikation der Implementierung anhand der durch das Modell spezifizierten Zustände über die erzeugten Testfälle vorgenommen. Die Verifikation könnte dank der erzeugten Testfälle auch ausgelagert werden und beispielsweise automatisch durchgeführt werden, sobald ein neuer Build der Implementierung entsteht. Die Testfälle müssen erst neu erzeugt werden, wenn sich die Anforderungen und damit das Modell der Software ändern.

\section{Umgebung}
Abbildung \ref{fig:seworkflow} illustriert den Ablauf des Testens mit Spec Explorer. Dabei werden unter anderem die drei Bestandteile der Umgebung dargestellt (die Implementierung, das Modell und die erzeugten Testfälle) und in wie diese zusammenhängen.

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{seworkflow.png}
\caption{Schematische Darstellung des Arbeitsablaufs bei der Verwendung von Spec Explorer}
\label{fig:seworkflow}
\end{figure}

In der semantischen Darstellung wird davon ausgegangen, dass bereits eine Implementierung besteht, die anhand eines ebenfalls bestehenden Modells verifiziert wird. Selbstverständlich könnte auch nur ein Modell existieren und die Implementierung würde erst nach der Testfallerzeugung im Rahmen eines \textit{Test Driven Development}-Ansatzes entstehen. Ebenfalls kann eine bestehende Implementierung auch nachträglich getestet werden, indem das Modell nachträglich entsteht. Eine gute Spezifikation entsteht jedenfalls dann, wenn Modell und Implementierung möglichst unabhängig voneinander entstehen.
\\
In diesem Abschnitt werden die Zusammenhänge von Implementierung, Modell und Konfiguration des Modells beschrieben. 

\subsection{Implementierung}
Der erste Teil einer Spec Explorer Umgebung besteht aus der Implementierung.

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{seimplementation1.png}
\caption{Fehlerhafte Implementierung}
\label{fig:seimplementation1}
\end{figure}

\subsection{Modell}
Der zweite Teil einer Spec Explorer Umgebung besteht aus dem Modell.

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{semodel.png}
\caption{Das Modell der Implementierung}
\label{fig:semodel}
\end{figure}

\subsection{Konfiguration}
Der zweite Teil einer Spec Explorer Umgebung enthält neben dem Modell auch eine Konfiguration. Diese Konfiguration besteht aus \textit{configs}.

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{seconfig1.png}
\caption{Die Konfiguration der Modellexploration}
\label{fig:seconfig1}
\end{figure}

Die Konfiguration besteht ebenfalls aus \textit{machines}.

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{seconfig2.png}
\caption{Die Konfiguration der Modell-Maschinen}
\label{fig:seconfig2}
\end{figure}

\section{Exploration}

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{seexploration.png}
\caption{Darstellung der Exploration des Modells als Zustandsautomat}
\label{fig:seexploration}
\end{figure}

\section{Szenarien}

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{sescenario.png}
\caption{Darstellung eines Szenarios als Zustandsautomat}
\label{fig:sescenario}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{seslicedscenario1.png}
\caption{Darstellung eines Szenarios in Verbindung mit der Zustandsraum-Exploration}
\label{fig:seslicedscenario1}
\end{figure}

\section{Testfälle}

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{seslicedscenario2.png}
\caption{Darstellung aller testbaren Ausprägungen eines Szenarios}
\label{fig:seslicedscenario2}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{setestcode1.png}
\caption{Codeausschnitt eines erzeugten Testfalls}
\label{fig:setestcode1}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{setestcode2.png}
\caption{Codeausschnitt einer Test-Methode im erzeugten Testfall}
\label{fig:setestcode2}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{seimplementation2.png}
\caption{Korrigierte Implementierung}
\label{fig:seimplementation2}
\end{figure}

\chapter{Visual Studio Integration}
\label{chap:vsintegration}

\section{Exploration Manager}
\label{sec:explorationmanager}

\section{UML Extensions}

\section{Testing Tools}



\chapter{Einsatz bei Microsoft}



\chapter{Fazit}



\bibliography{SpecExplorer}
\bibliographystyle{alpha}

\end{document}
