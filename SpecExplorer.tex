\documentclass[
a4paper, 							% Papierformat
%10pt,								% Schriftgröße (12pt, 11pt (Standard))
%twoside,							% Doppelseiten
titlepage,						% Titelei auf eigener Seite
normalheadings,				% Überschriften etwas kleiner (smallheadings)
%idxtotoc,						% Index im Inhaltsverzeichnis
%liststotoc,					% Abb.- und Tab.verzeichnis im Inhalt
%bibtotoc,						% Literaturverzeichnis im Inhalt
%leqno,   						% Nummerierung von Gleichungen links
%fleqn,								% Ausgabe von Gleichungen linksbündig
%draft								% überlangen Zeilen in Ausgabe gekennzeichnet
]
{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[isolatin]{inputenc}
\usepackage{graphicx}
\usepackage{url}

\begin{document}

\tableofcontents



\chapter{Einführung}
\label{chap:einfuehrung}
In dieser Seminararbeit soll das Programm Spec Explorer vorgestellt werden. Dabei handelt es sich um eine Anwendung die modellbasiertes Testen unterstützt. Spec Explorer ist seit 2010 ein Visual Studio Power Tool \cite{DuWors2010} und integriert sich als Erweiterung in die Entwicklungsumgebung von Microsoft ab Version 2010 Professional. Über die Visual Studio Gallery kann das Tool installiert werden \cite{Microsoft2010}.
\\\\
Traditionelles Testen von Software wird oft manuell vorgenommen. Das bedeutet das ein Mensch das Programm bedient und sämtliche Szenarien und Testfälle ausprobiert und mit einem erwarteten Ergebnis vergleicht. Da Software im Laufe der Zeit immer komplexer geworden ist und die realisierten Szenarien pro Anwendung zugenommen haben, wurden Tests zunehmend automatisiert. Testfälle müssen so nur noch einmal spezifiziert werden und können dann automatisiert durchgeführt werden. Diese Automatisierung erlaubt ein wesentlich effizienteres Testen und reduziert das menschliche Fehlerpotenzial.
\\
Ein Softwaresystem kann auf verschiedenen Ebenen getestet werden. Bisher wurde der Begriff des Testen verallgemeinert verwendet. Eine Ebene für Tests stellt die komplette Anwendung dar, in der Szenarien wie von einem Nutzer ausgeführt getestet werden können. Eine weitere Ebene ist eine logisch zusammengehörende Einheit von Programmcode (Unit). Hier werden die einzelnen Bausteine des komplexen Systems isoliert voneinander getestet. Eine dritte Ebene fast mehrere isolierte Bausteine zusammen und testet deren Zusammenarbeit als Szenario.
\\
Testfälle der ersten Ebene werden meistens von den Benutzern des Systems definiert, um die allgemeine Funktionsfähigkeit festzustellen. Tests der zweiten Ebene werden meistens nur von Entwicklern definiert um die Korrektheit des Programmcode sicherzustellen. Tests der dritten Ebene werden meistens von Entwicklern, Projektleitern und Benutzern definiert.
\\\\
Nachdem unterschiedliche Arten des Testen kurz vorgestellt wurden bleibt bei jeder Art eine Schwierigkeit. Testfälle müssen definiert werden und zwar so, dass sie die Anwendung möglichst ausführlich getestet wird. Bei zunehmender Komplexität der Anwendung und zunehmender Agilität der Anwendungsentwicklung stellt dies eine Herausforderung für Entwickler dar, da diese nicht nur den Programmcode, sondern auch den Testcode schreiben müssen. Spec Explorer ist ein Werkzeug das Entwickler bei der Testfallerzeugung und Lösung dieses Problems unterstützen kann.
\\
Was als wissenschaftliche Disziplin \cite{Gurevich1993} begann, findet mit Tools wie Spec Explorer Einzug in die Softwareentwicklung. Die zu testende Anwendung wird zunächst in einer abstrakten Form modelliert. Aus diesem Modell lassen sich anschließend Testfälle erzeugen, die auf den Programmcode der Anwendung angewendet werden können und die Anwendung so anhand des Modells validieren.



\chapter{Abstract State Machines}
\label{chap:asm}
Ein Computerprogramm ist ein Folge von Anweisungen die sequentiell ausgeführt werden. Eine solche Anweisung entspricht einer Zustandsänderung des Programms. Die Menge aller Zustandsänderungen repräsentiert die Funktionsweise des Systems. Yuri Gurevich hat 1999 \cite{Gurevich1999} gezeigt, dass ein solches System in einer von ihm erdachten Struktur namens \textit{Abstract State Machine} abgebildet werden kann. Laut ihm kann jeder Algorithmus, egal wie abstrakt, so modelliert werden. Eine \textit{Abstract State Machine}, 1993 unter der Bezeichnung \textit{Evolving Algebra} vorgestellt \cite{Gurevich1993}, ist ein Zustandsautomat, der Zustände nicht als explizite Dinge betrachtet. Laut Gurevich sind Zustände ambient im System vorhanden und entstehen implizit durch Veränderung von veränderlichen Eigenschaften des Systems. Auch die Zustände in einem Computerprogramm sind abstrakt und werden durch die Anweisungen des Programms verändert. Die gleichen Zustandsänderungen können durch von Gurevich als update-Anweisungen bezeichnete Ausdrücke vorgenommen werden. Gurevich's \textit{Abstract State Machine} kann damit wie in der Abbildung \ref{fig:asmschema} als eine Folge von update-Anweisungen dargestellt werden, die jeweils von einer guard-Annweisung begleitet werden. Die guard-Anweisung vergleicht den Zustand des Systems mit einem Erwartungswert und führt bei einer Übereinstimmung die zugehörige update-Anweisung aus. Die \textit{Abstract State Machine} läuft die Folge immer wieder durch und stellt somit das Programm der Zustandsmaschine dar. Endzustände, Abbruchbedingungen und andere Notationen können ebenfalls definiert werden.

\begin{figure}[htbp]
\centering
\includegraphics[height=120px]{asmschema.png}
\caption{Schematische Darstellung einer \textit{Abstract State Machine}}
\label{fig:asmschema}
\end{figure}

Das Konzept der \textit{Abstract State Machine} wird auch durch Egon Börger in Form eines Tutorials \cite{Boerger} zusammengefasst. Ihm zufolge entspricht der aktuelle Zustand im System der aktuellen konkreten Ausprägung aller Variablen in diesem System. Die Menge aller Zustände ist somit durch die Wertebereiche aller Variablen im System definiert. Zusammen mit Robert Stärk hat Egon Börger 2003 seine Abhandlungen in dem sogenannten \textit{AsmBook} zusammengefasst \cite{EgonBoerger2003}.



\chapter{Entwicklung von Spec Explorer}
Nachdem der Begriff des Testen in Kapitel \ref{chap:einfuehrung} eingeführt und das Konzept von abstrakten Zuständen in Kapitel \ref{chap:asm} erläutert wurde, beschäftigt sich dieses Kapitel mit dem Werdegang der Visual Studio Erweiterung Spec Explorer. Wolfgang Grieskamp beschreibt in seinem Blogeintrag \cite{Grieskamp2009} die Entwicklung von der theoretischen Idee der \textit{Abstract State Machine} bis zu einem allgemeinen Programm das von Entwicklern genutzt werden kann.

\section{AsmL}
Nachdem Gurevich 1999 die theoretische Grundlage gelegt \cite{Gurevich1999} hat, wurde die erste Implementierung einer Beschreibungssprache für \textit{Abstract State Machines} von einem Team in Microsoft vorgenommen. Diese Sprache wurde unter der Bezeichnung \textit{AsmL} (Abstract State Machine Language) bekannt. Laut Grieskamp \cite{Grieskamp2009} waren neben ihm selbst auch Yuri Gurevich, Margus Veanes, Wolfram Schulte, Lev Nachmanson, Colin Campbell und Nikolai Tillmann an der Entwicklung der Sprache beteiligt. Das Projekt wurde nie vollständig released und war eher ein Forschungsprojekt. \textit{AsmL} wurde nicht zum Testen, wie in Kapitel \ref{chap:einfuehrung} vorgestellt, entwickelt, sondern diente dem formalen Beweisen der Korrektheit von Softwaresystemen. Auf der Codeplex-Seite von \textit{AsmL} \cite{Microsoft2003} kann der Quellcode eines Binärcompilers heruntergeladen werden.

\section{AsmL-T}
Ein erster Ansatz \textit{AsmL} zum Testen von Softwaresystemen zu verwenden, wurde mit einer Erweiterung der Sprache unter dem Namen \textit{AsmL-T} von Wolfgang Grieskamp und Nikolai Tillmann entwickelt \cite{Grieskamp2009}. Eine wesentliche Ergänzung war die Funktion sämtliche Zustände des mit einer \textit{Abstract State Machine} beschriebenen Softwaresystems explorativ zu ermitteln. Grieskamp nennt dieses Feature \textit{state space exploration}. Damit war das erste modellbasierte Test-Werkzeug entwickelt.
\\
\textit{AsmL-T} wurde laut Grieskamp \cite{Grieskamp2009} verwendet, um die \textit{WCF} (Windows Communication Foundation) Implementierung zu testen. Angeblich wurde das Testen mithilfe von \textit{AsmL-T} beliebter und bekannter als die \textit{AsmL}-Sprache selber.

\section{Spec$\#$}
Aufgrund des zunehmendem Desinteresse an \textit{AsmL} wurde laut Grieskamp \cite{Grieskamp2009} eine neue Implementierung benötigt. Aus diesem Grund entstand \textit{Spec$\#$} als leichtgewichtige \textit{AsmL}-Implementierung. \textit{Spec$\#$} nutzt die Syntax von C$\#$ und nutzte als erste Sprache sogenannte \textit{Code Contracts}. Obwohl C$\#$-Syntax verwendet wird, wird für \textit{Spec$\#$} ein spezieller Compiler benötigt. Wahrscheinlich hat sich auch \textit{Spec$\#$} aus diesum Grund bis heute noch nicht durchgesetzt. Ob \textit{Spec$\#$} die \textit{AsmL}-Implementierung in \textit{AsmL-T} ersetzte, geht aus Grieskamps Blogpost \cite{Grieskamp2009} leider nicht hervor. 2004 wurde \textit{AsmL-T} dann Microsoft-intern unter dem Namen Spec Explorer 2004 veröffentlicht.

\section{PEX}	
Laut Grieskamp \cite{Grieskamp2009} wurde das Team, das sich bei Microsoft mit der Entwicklung von Spec Explorer 2004 beschäftigt, 2005 getrennt. Während sich ein kleiner Teil des ursprünglichen Teams weiterhin mit der Entwicklung von modellbasierten Test-Werkzeugen beschäftigt, wurde ein neues Team gegründet. Dieses neue Team entwickelte ein Programm, das zu testenden Programmcode analysiert und Eingabewerte ermittelt, die zu einer möglichst hohen Testabdeckung des zu testenden Programmcodes führen. Dieses Programm wurde inzwischen unter dem Namen \textit{PEX} veröffentlicht.



\chapter{Modellbasiertes Testen}
Spec Explorer ist ein modellbasiertes Test-Werkzeug. Dieses Kapitel beschäftigt sich damit, was modellbasiertes Testen überhaupt heißt. Nico Kicillof beschreibt MBT (Model Based Testing) in seinem Blogppost \cite{Kicillof2009} als leichtgewichtige und formale Methode um ein Softwaresystem zu validieren. MBT ist formal, weil es auf einer formalen, also Maschinen leserlichen Spezifikation, also dem Modell der Software arbeitet, die getestet werden soll. Kicillof nennt eine solche Software \textit{System Under Test}. Weiterhin ist MBT leichtgewichtig, da es im Gegensatz zu anderen formalen Methoden keinen mathematischen Beweis anstrebt um zu zeigen das die Implementierung der Spezifikation unter allen möglichen Umständen entspricht. MBT erzeugt aus einem Modell systematisch eine Menge von Testfällen, die auch \textit{test suite} genannt wird. Diese Testfälle, wenn sie auf die Implementierung des Systems angewendet werden, bieten ausreichende Überzeugung, dass das \textit{System Under Test} sich so verhält, wie sein Modell es definiert hat. Laut Kicillof \cite{Kicillof2009} ist der Unterschied zwischen leichtgewichtigen und schwergewichtigen formalen Methoden der Unterschied zwischen ausreichender Überzeugung und vollständiger Sicherheit. Allerdings sei der Preis für absolute Sicherheit sehr hoch, da schwergewichtige Methoden benötigt werden, die nur sehr schwierig angewendet werden können. Der leichtgewichtige MBT-Ansatz dagegen, würde laut Kicillof, viel besser skalieren und wurde bereits erfolgreich in großen Projekten, auch innerhalb Microsoft, angewendet.

\section{Anwendung}
Model-based Software Testing and Analysis with C$\#$ (Cambridge University Press, 2008)
\\Jonathan Jacky, Margus Veanes, Colin Campbell, Wolfram Schulte
\\http://staff.washington.edu/jon/modeling-book/
\\Open-source implementation called NModel http://nmodel.codeplex.com/

\section{Schwierigkeiten}
Multi-paradigmatic Model-Based Testing (Springer-Verlag, 2006)
\\Wolfgang Grieskamp
\\http://www.springerlink.com/content/087hx3160357088u

\subsection{State Explosion}

\subsection{Spezifikation}

\subsection{Zustände und Szenarien}

\subsection{IDE Unterstützung}

\subsection{Testfallerzeugung}



\chapter{Spec Explorer 2010}

\section{Die Lösung}
SpecExplorer 2010
\\Erster Prototype 2006
\\Model exploration auf der CIL (C$\#$ as input notation)
\\Scripting language CORD
\\Visual Studio integration
\\Automatische Test suite Erzeugung für Microsoft.VisualStudio.TestTools.UnitTesting

\section{Umgebung}

\subsection{Implementierung}

\subsection{Modell}

\subsection{Konfiguration}

\section{Exploration}

\section{Szenarien}

\section{Testfälle}



\chapter{Visual Studio Integration}

\section{Exploration Manager}

\section{UML Extensions}

\section{Testing Tools}



\chapter{Einsatz bei Microsoft}



\chapter{Fazit}



\bibliography{SpecExplorer}
\bibliographystyle{alpha}

\end{document}
