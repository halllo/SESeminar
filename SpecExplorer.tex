\documentclass[
a4paper, 							% Papierformat
%10pt,								% Schriftgröße (12pt, 11pt (Standard))
%twoside,							% Doppelseiten
titlepage,						% Titelei auf eigener Seite
normalheadings,				% Überschriften etwas kleiner (smallheadings)
%idxtotoc,						% Index im Inhaltsverzeichnis
%liststotoc,					% Abb.- und Tab.verzeichnis im Inhalt
%bibtotoc,						% Literaturverzeichnis im Inhalt
%leqno,   						% Nummerierung von Gleichungen links
%fleqn,								% Ausgabe von Gleichungen linksbündig
%draft								% überlangen Zeilen in Ausgabe gekennzeichnet
]
{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[isolatin]{inputenc}
\usepackage{graphicx}
\usepackage{url}

\begin{document}

\tableofcontents



\chapter{Einführung}
\label{chap:einfuehrung}
In dieser Seminararbeit soll das Programm Spec Explorer vorgestellt werden. Dabei handelt es sich um eine Anwendung die modellbasiertes Testen unterstützt. Spec Explorer ist seit 2010 ein Visual Studio Power Tool \cite{DuWors2010} und integriert sich als Erweiterung in die Entwicklungsumgebung von Microsoft ab Version 2010 Professional. Über die Visual Studio Gallery kann das Tool installiert werden \cite{Microsoft2010}.
\\\\
Traditionelles Testen von Software wird oft manuell vorgenommen. Das bedeutet das ein Mensch das Programm bedient und sämtliche Szenarien und Testfälle ausprobiert und mit einem erwarteten Ergebnis vergleicht. Da Software im Laufe der Zeit immer komplexer geworden ist und die realisierten Szenarien pro Anwendung zugenommen haben, wurden Tests zunehmend automatisiert. Testfälle müssen so nur noch einmal spezifiziert werden und können dann automatisiert durchgeführt werden. Diese Automatisierung erlaubt ein wesentlich effizienteres Testen und reduziert das menschliche Fehlerpotenzial.
\\
Ein Softwaresystem kann auf verschiedenen Ebenen getestet werden. Bisher wurde der Begriff des Testen verallgemeinert verwendet. Eine Ebene für Tests stellt die komplette Anwendung dar, in der Szenarien wie von einem Nutzer ausgeführt getestet werden können. Eine weitere Ebene ist eine logisch zusammengehörende Einheit von Programmcode (Unit). Hier werden die einzelnen Bausteine des komplexen Systems isoliert voneinander getestet. Eine dritte Ebene fast mehrere isolierte Bausteine zusammen und testet deren Zusammenarbeit als Szenario.
\\
Testfälle der ersten Ebene werden meistens von den Benutzern des Systems definiert, um die allgemeine Funktionsfähigkeit festzustellen. Tests der zweiten Ebene werden meistens nur von Entwicklern definiert um die Korrektheit des Programmcode sicherzustellen. Tests der dritten Ebene werden meistens von Entwicklern, Projektleitern und Benutzern definiert.
\\\\
Nachdem unterschiedliche Arten des Testen kurz vorgestellt wurden bleibt bei jeder Art eine Schwierigkeit. Testfälle müssen definiert werden und zwar so, dass sie die Anwendung möglichst ausführlich getestet wird. Bei zunehmender Komplexität der Anwendung und zunehmender Agilität der Anwendungsentwicklung stellt dies eine Herausforderung für Entwickler dar, da diese nicht nur den Programmcode, sondern auch den Testcode schreiben müssen. Spec Explorer ist ein Werkzeug das Entwickler bei der Testfallerzeugung und Lösung dieses Problems unterstützen kann.
\\
Was als wissenschaftliche Disziplin \cite{Gurevich1993} begann, findet mit Tools wie Spec Explorer Einzug in die Softwareentwicklung. Die zu testende Anwendung wird zunächst in einer abstrakten Form modelliert. Aus diesem Modell lassen sich anschließend Testfälle erzeugen, die auf den Programmcode der Anwendung angewendet werden können und die Anwendung so anhand des Modells validieren.



\chapter{Abstract State Machines}
\label{chap:asm}
Ein Computerprogramm ist ein Folge von Anweisungen die sequentiell ausgeführt werden. Eine solche Anweisung entspricht einer Zustandsänderung des Programms. Die Menge aller Zustandsänderungen repräsentiert die Funktionsweise des Systems. Yuri Gurevich hat 1999 \cite{Gurevich1999} gezeigt, dass ein solches System in einer von ihm erdachten Struktur namens \textit{Abstract State Machine} abgebildet werden kann. Laut ihm kann jeder Algorithmus, egal wie abstrakt, so modelliert werden. Eine \textit{Abstract State Machine}, 1993 unter der Bezeichnung \textit{Evolving Algebra} vorgestellt \cite{Gurevich1993}, ist ein Zustandsautomat, der Zustände nicht als explizite Dinge betrachtet. Laut Gurevich sind Zustände ambient im System vorhanden und entstehen implizit durch Veränderung von veränderlichen Eigenschaften des Systems. Auch die Zustände in einem Computerprogramm sind abstrakt und werden durch die Anweisungen des Programms verändert. Die gleichen Zustandsänderungen können durch von Gurevich als update-Anweisungen bezeichnete Ausdrücke vorgenommen werden. Gurevich's \textit{Abstract State Machine} kann damit wie in der Abbildung \ref{fig:asmschema} als eine Folge von update-Anweisungen dargestellt werden, die jeweils von einer guard-Annweisung begleitet werden. Die guard-Anweisung vergleicht den Zustand des Systems mit einem Erwartungswert und führt bei einer Übereinstimmung die zugehörige update-Anweisung aus. Die \textit{Abstract State Machine} läuft die Folge immer wieder durch und stellt somit das Programm der Zustandsmaschine dar. Endzustände, Abbruchbedingungen und andere Notationen können ebenfalls definiert werden.

\begin{figure}[htbp]
\centering
\includegraphics[height=120px]{asmschema.png}
\caption{Schematische Darstellung einer \textit{Abstract State Machine}}
\label{fig:asmschema}
\end{figure}

Das Konzept der \textit{Abstract State Machine} wird auch durch Egon Börger in Form eines Tutorials \cite{Boerger} zusammengefasst. Ihm zufolge entspricht der aktuelle Zustand im System der aktuellen konkreten Ausprägung aller Variablen in diesem System. Die Menge aller Zustände ist somit durch die Wertebereiche aller Variablen im System definiert. Zusammen mit Robert Stärk hat Egon Börger 2003 seine Abhandlungen in dem sogenannten \textit{AsmBook} zusammengefasst \cite{EgonBoerger2003}.



\chapter{Entwicklung von Spec Explorer}
Nachdem der Begriff des Testen in Kapitel \ref{chap:einfuehrung} eingeführt und das Konzept von abstrakten Zuständen in Kapitel \ref{chap:asm} erläutert wurde, beschäftigt sich dieses Kapitel mit dem Werdegang der Visual Studio Erweiterung Spec Explorer. Wolfgang Grieskamp beschreibt in seinem Blogeintrag \cite{Grieskamp2009} die Entwicklung von der theoretischen Idee der \textit{Abstract State Machine} bis zu einem allgemeinen Programm das von Entwicklern genutzt werden kann.

\section{AsmL}
Nachdem Gurevich 1999 die theoretische Grundlage gelegt \cite{Gurevich1999} hat, wurde die erste Implementierung einer Beschreibungssprache für \textit{Abstract State Machines} von einem Team in Microsoft vorgenommen. Diese Sprache wurde unter der Bezeichnung \textit{AsmL} (Abstract State Machine Language) bekannt. Laut Grieskamp \cite{Grieskamp2009} waren neben ihm selbst auch Yuri Gurevich, Margus Veanes, Wolfram Schulte, Lev Nachmanson, Colin Campbell und Nikolai Tillmann an der Entwicklung der Sprache beteiligt. Das Projekt wurde nie vollständig released und war eher ein Forschungsprojekt. \textit{AsmL} wurde nicht zum Testen, wie in Kapitel \ref{chap:einfuehrung} vorgestellt, entwickelt, sondern diente dem formalen Beweisen der Korrektheit von Softwaresystemen. Auf der Codeplex-Seite von \textit{AsmL} \cite{Microsoft2003} kann der Quellcode eines Binärcompilers heruntergeladen werden.

\section{AsmL-T}
Ein erster Ansatz \textit{AsmL} zum Testen von Softwaresystemen zu verwenden, wurde mit einer Erweiterung der Sprache unter dem Namen \textit{AsmL-T} von Wolfgang Grieskamp und Nikolai Tillmann entwickelt \cite{Grieskamp2009}. Eine wesentliche Ergänzung war die Funktion sämtliche Zustände des mit einer \textit{Abstract State Machine} beschriebenen Softwaresystems explorativ zu ermitteln. Grieskamp nennt dieses Feature \textit{state space exploration}. Damit war das erste modellbasierte Test-Werkzeug entwickelt.
\\
\textit{AsmL-T} wurde laut Grieskamp \cite{Grieskamp2009} verwendet, um die \textit{WCF} (Windows Communication Foundation) Implementierung zu testen. Angeblich wurde das Testen mithilfe von \textit{AsmL-T} beliebter und bekannter als die \textit{AsmL}-Sprache selber.

\section{Spec$\#$}
Aufgrund des zunehmendem Desinteresse an \textit{AsmL} wurde laut Grieskamp \cite{Grieskamp2009} eine neue Implementierung benötigt. Aus diesem Grund entstand \textit{Spec$\#$} als leichtgewichtige \textit{AsmL}-Implementierung. \textit{Spec$\#$} nutzt die Syntax von C$\#$ und nutzte als erste Sprache sogenannte \textit{Code Contracts}. Obwohl C$\#$-Syntax verwendet wird, wird für \textit{Spec$\#$} ein spezieller Compiler benötigt. Wahrscheinlich hat sich auch \textit{Spec$\#$} aus diesum Grund bis heute noch nicht durchgesetzt. Ob \textit{Spec$\#$} die \textit{AsmL}-Implementierung in \textit{AsmL-T} ersetzte, geht aus Grieskamps Blogpost \cite{Grieskamp2009} leider nicht hervor. 2004 wurde \textit{AsmL-T} dann Microsoft-intern unter dem Namen Spec Explorer 2004 veröffentlicht.

\section{PEX}	
Laut Grieskamp \cite{Grieskamp2009} wurde das Team, das sich bei Microsoft mit der Entwicklung von Spec Explorer 2004 beschäftigt, 2005 getrennt. Während sich ein kleiner Teil des ursprünglichen Teams weiterhin mit der Entwicklung von modellbasierten Test-Werkzeugen beschäftigt, wurde ein neues Team gegründet. Dieses neue Team entwickelte ein Programm, das zu testenden Programmcode analysiert und Eingabewerte ermittelt, die zu einer möglichst hohen Testabdeckung des zu testenden Programmcodes führen. Dieses Programm wurde inzwischen unter dem Namen \textit{PEX} veröffentlicht.



\chapter{Modellbasiertes Testen}
Spec Explorer ist ein modellbasiertes Test-Werkzeug. Dieses Kapitel beschäftigt sich damit, was modellbasiertes Testen überhaupt heißt. Nico Kicillof beschreibt MBT (Model Based Testing) in seinem Blogppost \cite{Kicillof2009} als leichtgewichtige und formale Methode um ein Softwaresystem zu validieren. MBT ist formal, weil es auf einer formalen, also Maschinen leserlichen Spezifikation, also dem Modell der Software arbeitet, die getestet werden soll. Kicillof nennt eine solche Software \textit{System Under Test}. Weiterhin ist MBT leichtgewichtig, da es im Gegensatz zu anderen formalen Methoden keinen mathematischen Beweis anstrebt um zu zeigen das die Implementierung der Spezifikation unter allen möglichen Umständen entspricht. MBT erzeugt aus einem Modell systematisch eine Menge von Testfällen, die auch \textit{test suite} genannt wird. Diese Testfälle, wenn sie auf die Implementierung des Systems angewendet werden, bieten ausreichende Überzeugung, dass das \textit{System Under Test} sich so verhält, wie sein Modell es definiert hat. Laut Kicillof \cite{Kicillof2009} ist der Unterschied zwischen leichtgewichtigen und schwergewichtigen formalen Methoden der Unterschied zwischen ausreichender Überzeugung und vollständiger Sicherheit. Allerdings sei der Preis für absolute Sicherheit sehr hoch, da schwergewichtige Methoden benötigt werden, die nur sehr schwierig angewendet werden können. Der leichtgewichtige MBT-Ansatz dagegen, würde laut Kicillof, viel besser skalieren und wurde bereits erfolgreich in großen Projekten, auch innerhalb Microsoft, angewendet.

\section{Anwendung}
Nachdem die theoretischen Grundlagen des modellbasierten Testen erwähnt wurden, beschäftigt sich dieser Abschnitt mit der Anwendung der Methode. Neben vielen Texten im Internet gibt es ein Schriftstück, das besondere Authorität genießt. Margus Veanes, Colin Campbell und Wolfram Schulte haben das Spec Explorer Team bei Microsoft verlassen und zusammen mit Jonathan Jacky ein Buch über modellbasiertes Testen mit C$\#$ veröffentlicht \cite{JonathanJacky2008}. Zu diesem Buch haben besagt vier eine open-source Implementierung eines modellbasierten Test-Werkzeugs namens \textit{NModel} released \cite{Microsoft2008}, welches auf der codeplex-Seite kostenlos heruntergeladen kann. Inwiefern \textit{NModel} die gleichen Funktionen wie Spec Explorer besitzt, konnte im Rahmen dieser Seminararbeit leider nicht näher untersucht werden.

\section{Schwierigkeiten}
Obwohl die Methode des modellbasierten Testen laut Nico Kicillof \cite{Kicillof2009} wesentlich einfacher und besser anwendbar als andere Verifikationsverfahren sind, bestehen auch hier einige Schwierigkeiten. Wolfgang Grieskamp hat sich in seinem Buch \cite{Grieskamp2006} mit diesen Problemen auseinander gesetzt. In den folgenden Unterabschnitten werden die fünf Probleme näher beschrieben, die die effektive Nutzung der Methode mithilfe eines Werkzeugs besonders schwierig oder umständlich machen.

\subsection{State Explosion}
\label{subsec:stateexplosion}
Wolfgang Grieskamp beschreibt in seinem Buch \cite{Grieskamp2006} und in seinem Blogpost \cite{Grieskamp2009} das Problem, dass in einer Anwendung sehr viele Zustände existieren als \textit{State Explosion}. Die Durchführung einer \textit{State Space Exploration}, also das ermitteln aller Zustände eines Systems, wird insofern erheblich erschwert, da signifikante Zustände einfach nicht mehr in der Fülle von unwichtigen Zuständen erkannt werden können. Weiterhin besteht die Möglichkeit einer unendlich großen Zustandsmenge im Falle der Verwendung einer Listen-artigen Datenstruktur. Eine Operation, die auf einer Liste ausgeführt werden kann, hat für jede Konfiguration der Liste einen Zustand als Vorbedingung. Wenn eine Liste theoretisch unendlich viele Elemente enthalten kann, existieren unendlich viele Vorbedingungen. Ähnlich ist das wenn Objekte dynamisch instantiiert werden. Für jedes neue Objekt existiert eine neue Vorbedingung für jede globale Operation. Dieses Phänomen beschreibt Grieskamp als \textit{State Explosion}, da die Menge der Zustände sprichwörtlich explodiert, also unkontrollierbar groß wird.

\subsection{Spezifikation}
Ein weiteres von Wolfgang Grieskamp beschriebenes \cite{Grieskamp2006} Problem besteht in der Art und Weise wie ein Modell spezifiziert wird. In \textit{AsmL-T} wurde ein Modell in \textit{AsmL} spezifiziert und erforderte somit die Kenntnis der Sprache. Für Wissenschaftler ist dies kein Problem, für die Industrie schon. Da ein Modell eine Realität besonders einfach und abstrahiert repräsentieren soll, sollte dieses Modell auch ohne großen Aufwand erstellt werden können. Die Schwierigkeit der Modellerzeugung sollte in der Formalisierung der Anforderungen liegen und nicht in der technischen Übersetzung der Anforderung in eine spezielle Sprache. Je einfacher eine solche Sprache nutzbar ist, desto unwahrscheinlicher ist die Einführung von Fehlern bei der Formalisierung der Anforderungen.

\subsection{Zustände und Szenarien}
In Unterabschnitt \ref{subsec:stateexplosion} wurde die Menge an ermittelten Zuständen bereits erwähnt. Da Zustände in Unterschiedlichen Kontexten auftreten können, ist eine Abstraktion von diesen Zuständen erforderlich, um die Funktion der Implementierung den Zuständen zuordnen zu können. Wolfgang Grieskamp beschreibt \cite{Grieskamp2006} eine Lösung dieses Problem als Szenario-Orientierung. Ein Szenario ist ein Ablauf von verschiedenen Funktionen des Systems. Das System erreicht darin mehrere Zustände in einer Reihenfolge. Ein Beispiel für ein Szenario wäre: Benutzer meldet sich am System an, macht etwas und meldet sich wieder ab. Szenarien können daher auch \textit{User Stories} genannt werden. Laut Grieskamp \cite{Grieskamp2009} unterstützen viele MBT-Werkzeuge nur das Testen der der Zustände der Implementierung, nicht aber das Testen von Szenarien. Er sieht eine Schwierigkeit in der Kombination des Zustandsraums (State Space), der durch die \textit{State Space Exploration} generiert wird, mit den Aktions-orientierten Szenariobeschreibungen. Während \textit{Unit Tests}, wie sie in Kapitel \ref{chap:einfuehrung} beschrieben wurden, Szenarien testen, sollte ein MBT-Ansatz diese Szenarien ebenfalls testen können um eine vergleichbare Testgranularität gewährleisten zu können.

\subsection{IDE Unterstützung}
Wolfgang Grieskamp identifiziert in seinem Blogpost \cite{Grieskamp2009} die mangelnde Integration in Entwicklungswerkzeuge als weiteres Problem. Viele formale Verifikationsverfahren nutzen spezielle Programm, die Wissenschaftler bedienen können, Entwickler dagegen in der Regel nicht verstehen. Wenn die Methode des modellbasierten Testen an Beliebtheit und Bekanntheit zunehmen soll, muss eine Umgebung genutzt werden, in der sich die Entwickler auskennen. Es kann allgemein als unrealistisch angesehen werden, dass ein Entwickler eine neue Umgebung erlernen wird, wenn er nur eine indirekte  Produktivitätssteigerung des sowieso unbeliebten Testen erreichen kann. Im Gegensatz ist eine Testumgebung, mit der der Entwickler bereits vertraut ist, die ideale Voraussetzung. Die zu testende Implementierung, das Modell und die Verifikation sollte laut Grieskamp über eine einheitliche Benutzerschnittstelle erreichbar sein. Da die IDE (Integrated Development Environment) bereits für die Implementierung des Systems genutzt wird, liegt eine Integration des MBT-Werkzeugs in dieses Programm nahe.

\subsection{Testfallerzeugung}
Wenn MBT-Werkzeuge eine Implementierung anhand eines Modells verifizieren, dann sollte der Prozess der Verifikation ebenfalls von einem Test Runner durchgeführt werden können, der auch \textit{normale} Tests durchführen kann. Wolfgang Grieskamp sieht in der fehlenden Unterstützung für Test Runner ein weiteres Problem \cite{Grieskamp2009} des MBT-Ansatzes. Die Verifikation anhand eines Modells sollte  ohne hohe Laufzeitkosten durchgeführt werden können, also ohne jedes mal eine \textit{State Space Exploration} durchführen zu müssen. Besonders vor dem Hintergrund von Continuous Integration ist eine automatische Verifikation als Teil eines automatisierten Buildvorgangs durchaus denkbar. Der Schritt des Testen der Implementierung sollte laut Grieskamp so allgemein wie möglich durchgeführt werden können und zwar auf eine Weise, die dem traditionellen Testen mit \textit{Unit Tests} sehr ähnlich ist. Eine Erzeugung der Testfälle für ein bekanntes Testing Framework würde das modellbasierte Testen, zumindest was den Schritt der Verifikation angeht, erheblich erleichtern.

\chapter{Spec Explorer 2010}

\section{Die Lösung}
SpecExplorer 2010
\\Erster Prototype 2006
\\Model exploration auf der CIL (C$\#$ as input notation)
\\Scripting language CORD
\\Visual Studio integration
\\Automatische Test suite Erzeugung für Microsoft.VisualStudio.TestTools.UnitTesting

\section{Umgebung}

\subsection{Implementierung}

\subsection{Modell}

\subsection{Konfiguration}

\section{Exploration}

\section{Szenarien}

\section{Testfälle}



\chapter{Visual Studio Integration}

\section{Exploration Manager}

\section{UML Extensions}

\section{Testing Tools}



\chapter{Einsatz bei Microsoft}



\chapter{Fazit}



\bibliography{SpecExplorer}
\bibliographystyle{alpha}

\end{document}
