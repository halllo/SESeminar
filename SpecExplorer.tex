\documentclass[
a4paper, 							% Papierformat
%10pt,								% Schriftgröße (12pt, 11pt (Standard))
%twoside,							% Doppelseiten
titlepage,						% Titelei auf eigener Seite
normalheadings,				% Überschriften etwas kleiner (smallheadings)
%idxtotoc,						% Index im Inhaltsverzeichnis
%liststotoc,					% Abb.- und Tab.verzeichnis im Inhalt
%bibtotoc,						% Literaturverzeichnis im Inhalt
%leqno,   						% Nummerierung von Gleichungen links
%fleqn,								% Ausgabe von Gleichungen linksbündig
%draft								% überlangen Zeilen in Ausgabe gekennzeichnet
]
{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[isolatin]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tipa}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm,includeheadfoot]{geometry}

\begin{document}



\thispagestyle{empty}
\begin{titlepage}
\begin{figure}[t]
	\centering
  \includegraphics[width=80mm]{HsKaLogoKlein.png}
	\vspace{2.5cm}
\end{figure}
\begin{center}
\title{Spec Explorer - A Model-Based Testing tool from Microsoft}
\textbf{\huge{Spec Explorer}} \\[0.5cm]
\textbf{A Model-Based Testing tool from Microsoft} \\[4cm]
\textbf{Seminararbeit} \\[0.25cm]
\author{Manuel Naujoks} Manuel Naujoks\\[2.5cm]
Betreut durch \\[0.25cm] 
Prof. Dr. Thomas Fuchß \\[2.5cm]
Bischweier, den \today
\end{center}
\end{titlepage}



\thispagestyle{empty}
\begin{center}\textbf{\large Erklärung}\\[1cm]\end{center}
Hiermit versichere ich, dass ich die vorliegende Arbeit selbstständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, dass alle Stellen der Arbeit, die wörtlich oder sinngemäß aus anderen Quellen übernommen wurden, als solche kenntlich gemacht sind und dass die Arbeit in gleicher oder ähnlicher Form noch keiner Prüfungsbehörde vorgelegt wurde.
\\[4\baselineskip]
Bischweier, den \today \\
Manuel Naujoks



\begingroup
\addtocontents{toc}{\protect\thispagestyle{empty}}
\pagestyle{empty}
\tableofcontents
\newpage
\setcounter{page}{1}
\endgroup



\chapter{Einführung}
In dieser Seminararbeit soll das Programm Spec Explorer vorgestellt werden. Dabei handelt es sich um eine Anwendung die modellbasiertes Testen unterstützt. Spec Explorer ist seit 2010 ein Visual Studio Power Tool \cite{DuWors2010} und integriert sich als Erweiterung in die Entwicklungsumgebung von Microsoft ab Version 2010 Professional. Über die Visual Studio Gallery kann das Tool installiert werden \cite{Microsoft2010}.
\\\\
In diesem Einführungs-Kapitel sollen die Grundlagen vermittelt werden, die für ein Verständnis des Spec Explorer Add-Ins erforderlich sind. Dazu wird in Abschnitt \ref{sec:testen} zunächst der Begriff des \textit{Testen} erläutert, bevor in Abschnitt \ref{sec:asm} auf das wissenschaftliche Konzept hinter dem Tool eingegangen wird. Spec Explorer implementiert eine Weiterentwicklung einer als \textit{Abstract State Machine} bekannten Notation von zustandsbehafteten Systemen. In Abschnitt \ref{sec:asmbisspecexplorer} wird anschließend beschrieben, wie das Konzept der abstrakten Zustandsmaschine Einfluss auf die Entwicklung der Visual Studio Erweiterung hatte. Dabei werden mehrere Technologien kurz vorgestellt, die als Zwischenschritte auf dem Weg von ASMs bis Spec Exploror gesehen werden können.

\section{Testen}
\label{sec:testen}
Traditionelles Testen von Software wird oft manuell vorgenommen. Das bedeutet das ein Mensch das Programm bedient und sämtliche Szenarien und Testfälle ausprobiert und mit einem erwarteten Ergebnis vergleicht. Da Software im Laufe der Zeit immer komplexer geworden ist und die realisierten Szenarien pro Anwendung zugenommen haben, wurden Tests zunehmend automatisiert. Testfälle müssen so nur noch einmal spezifiziert werden und können dann automatisiert durchgeführt werden. Ein Softwaresystem kann auf verschiedenen Ebenen getestet werden. Bisher wurde der Begriff des Testen verallgemeinert verwendet.

\begin{enumerate}
 \item Eine Ebene für Tests stellt die komplette Anwendung dar, in der Szenarien wie von einem Nutzer ausgeführt getestet werden können.
 \item Eine weitere Ebene ist eine logisch zusammengehörende Einheit von Programmcode (Unit). Hier werden die einzelnen Bausteine des komplexen Systems isoliert voneinander getestet.
 \item Eine dritte Ebene fast mehrere isolierte Bausteine zusammen und testet deren Zusammenarbeit als Szenario.
\end{enumerate}

Testfälle der ersten Ebene werden meistens von den Benutzern des Systems definiert, um die allgemeine Funktionsfähigkeit festzustellen. Tests der zweiten Ebene werden meistens nur von Entwicklern definiert um die Korrektheit des Programmcode sicherzustellen. Tests der dritten Ebene werden meistens von Entwicklern, Projektleitern und Benutzern definiert.
\\
Nachdem unterschiedliche Arten des Testen kurz vorgestellt wurden bleibt bei jeder Art eine Schwierigkeit. Testfälle müssen definiert werden und zwar so, dass sie die Anwendung möglichst ausführlich getestet wird. Bei zunehmender Komplexität der Anwendung und zunehmender Agilität der Anwendungsentwicklung stellt dies eine Herausforderung für Entwickler dar, da diese nicht nur den Programmcode, sondern auch den Testcode schreiben müssen. Spec Explorer ist ein Werkzeug das Entwickler bei der Testfallerzeugung und Lösung dieses Problems unterstützen kann.
\\
Was als wissenschaftliche Disziplin \cite{Gurevich1993} begann, findet mit Tools wie Spec Explorer Einzug in die Softwareentwicklung. Die zu testende Anwendung wird zunächst in einer abstrakten Form modelliert. Aus diesem Modell lassen sich anschließend Testfälle erzeugen, die auf den Programmcode der Anwendung angewendet werden können und die Anwendung so anhand des Modells validieren.

\section{Abstract State Machines}
\label{sec:asm}
Ein Computerprogramm ist ein Folge von Anweisungen die sequentiell ausgeführt werden. Eine solche Anweisung entspricht einer Zustandsänderung des Programms. Die Menge aller Zustandsänderungen repräsentiert die Funktionsweise des Systems. Yuri Gurevich hat 1999 \cite{Gurevich1999} gezeigt, dass ein solches System in einer von ihm erdachten Struktur namens \textit{Abstract State Machine} abgebildet werden kann. Laut ihm kann jeder Algorithmus, egal wie abstrakt, so modelliert werden. Eine \textit{Abstract State Machine}, 1993 unter der Bezeichnung \textit{Evolving Algebra} vorgestellt \cite{Gurevich1993}, ist ein Zustandsautomat, der Zustände nicht als explizite Dinge betrachtet. Laut Gurevich sind Zustände ambient im System vorhanden und entstehen implizit durch Veränderung von veränderlichen Eigenschaften des Systems. Auch die Zustände in einem Computerprogramm sind abstrakt und werden durch die Anweisungen des Programms verändert. Die gleichen Zustandsänderungen können durch von Gurevich als update-Anweisungen bezeichnete Ausdrücke vorgenommen werden. Gurevich's \textit{Abstract State Machine} kann damit wie in der Abbildung \ref{fig:asmschema} als eine Folge von update-Anweisungen dargestellt werden, die jeweils von einer guard-Annweisung begleitet werden. Die guard-Anweisung vergleicht den Zustand des Systems mit einem Erwartungswert und führt bei einer Übereinstimmung die zugehörige update-Anweisung aus. Die \textit{Abstract State Machine} läuft die Folge immer wieder durch und stellt somit das Programm der Zustandsmaschine dar. Endzustände, Abbruchbedingungen und andere Notationen können ebenfalls definiert werden.

\begin{figure}[htbp]
\centering
\includegraphics[height=120px]{asmschema.png}
\caption{Schematische Darstellung einer \textit{Abstract State Machine}}
\label{fig:asmschema}
\end{figure}

Das Konzept der \textit{Abstract State Machine} wird auch durch Egon Börger in Form eines Tutorials \cite{Boerger} zusammengefasst. Ihm zufolge entspricht der aktuelle Zustand im System der aktuellen konkreten Ausprägung aller Variablen in diesem System. Die Menge aller Zustände ist somit durch die Wertebereiche aller Variablen im System definiert. Zusammen mit Robert Stärk hat Egon Börger 2003 seine Abhandlungen in dem sogenannten \textit{AsmBook} zusammengefasst \cite{EgonBoerger2003}.

\section{Von ASMs bis Spec Explorer}
\label{sec:asmbisspecexplorer}
Nachdem der Begriff des Testen in Abschnitt \ref{sec:testen} eingeführt und das Konzept von abstrakten Zuständen in Kapitel \ref{sec:asm} erläutert wurde, beschäftigt sich dieses Kapitel mit dem Werdegang der Visual Studio Erweiterung Spec Explorer. Wolfgang Grieskamp beschreibt in seinem Blogeintrag \cite{Grieskamp2009} die Entwicklung von der theoretischen Idee der \textit{Abstract State Machine} bis zu einem allgemeinen Programm das von Entwicklern genutzt werden kann.

\subsection{AsmL}
Nachdem Gurevich 1999 die theoretische Grundlage gelegt \cite{Gurevich1999} hat, wurde die erste Implementierung einer Beschreibungssprache für \textit{Abstract State Machines} von einem Team in Microsoft vorgenommen. Diese Sprache wurde unter der Bezeichnung \textit{AsmL} (Abstract State Machine Language) bekannt. Laut Grieskamp \cite{Grieskamp2009} waren neben ihm selbst auch Yuri Gurevich, Margus Veanes, Wolfram Schulte, Lev Nachmanson, Colin Campbell und Nikolai Tillmann an der Entwicklung der Sprache beteiligt. Das Projekt wurde nie vollständig released und war eher ein Forschungsprojekt. \textit{AsmL} wurde nicht zum Testen, wie in Abschnitt \ref{sec:testen} vorgestellt, entwickelt, sondern diente dem formalen Beweisen der Korrektheit von Softwaresystemen. Auf der Codeplex-Seite von \textit{AsmL} \cite{Microsoft2003} kann der Quellcode eines Binärcompilers heruntergeladen werden.

\subsection{AsmL-T}
Ein erster Ansatz \textit{AsmL} zum Testen von Softwaresystemen zu verwenden, wurde mit einer Erweiterung der Sprache unter dem Namen \textit{AsmL-T} von Wolfgang Grieskamp und Nikolai Tillmann entwickelt \cite{Grieskamp2009}. Eine wesentliche Ergänzung war die Funktion sämtliche Zustände des mit einer \textit{Abstract State Machine} beschriebenen Softwaresystems explorativ zu ermitteln. Grieskamp nennt dieses Feature \textit{state space exploration}. Damit war das erste modellbasierte Test-Werkzeug entwickelt.
\\
\textit{AsmL-T} wurde laut Grieskamp \cite{Grieskamp2009} verwendet, um die \textit{WCF} (Windows Communication Foundation) Implementierung zu testen. Angeblich wurde das Testen mithilfe von \textit{AsmL-T} beliebter und bekannter als die \textit{AsmL}-Sprache selber.

\subsection{Spec$\#$}
\label{subsec:specsharp}
Aufgrund des zunehmendem Desinteresse an \textit{AsmL} wurde laut Grieskamp \cite{Grieskamp2009} eine neue Implementierung benötigt. Aus diesem Grund entstand \textit{Spec$\#$} als leichtgewichtige \textit{AsmL}-Implementierung. \textit{Spec$\#$} nutzt die Syntax von C$\#$ und nutzte als erste Sprache sogenannte \textit{Code Contracts}. Obwohl C$\#$-Syntax verwendet wird, wird für \textit{Spec$\#$} ein spezieller Compiler benötigt. Wahrscheinlich hat sich auch \textit{Spec$\#$} aus diesum Grund bis heute noch nicht durchgesetzt. Ob \textit{Spec$\#$} die \textit{AsmL}-Implementierung in \textit{AsmL-T} ersetzte, geht aus Grieskamps Blogpost \cite{Grieskamp2009} leider nicht hervor. 2004 wurde \textit{AsmL-T} dann Microsoft-intern unter dem Namen Spec Explorer 2004 veröffentlicht.

\subsection{PEX}	
Laut Grieskamp \cite{Grieskamp2009} wurde das Team, das sich bei Microsoft mit der Entwicklung von Spec Explorer 2004 beschäftigt, 2005 getrennt. Während sich ein kleiner Teil des ursprünglichen Teams weiterhin mit der Entwicklung von modellbasierten Test-Werkzeugen beschäftigt, wurde ein neues Team gegründet. Dieses neue Team entwickelte ein Programm, das zu testenden Programmcode analysiert und Eingabewerte ermittelt, die zu einer möglichst hohen Testabdeckung des zu testenden Programmcodes führen. Dieses Programm wurde inzwischen unter dem Namen \textit{PEX} veröffentlicht.



\chapter{Modellbasiertes Testen}
\label{chap:mbt}
Spec Explorer ist ein modellbasiertes Test-Werkzeug. Dieses Kapitel beschäftigt sich damit, was modellbasiertes Testen überhaupt bedeutet. Nico Kicillof beschreibt MBT (Model Based Testing) in seinem Blogppost \cite{Kicillof2009} als leichtgewichtige und formale Methode um ein Softwaresystem zu validieren. MBT ist formal, weil es auf einer formalen, also Maschinen leserlichen Spezifikation, also dem Modell der Software arbeitet, die getestet werden soll. Kicillof nennt eine solche Software \textit{System Under Test}. Weiterhin ist MBT leichtgewichtig, da es im Gegensatz zu anderen formalen Methoden keinen mathematischen Beweis anstrebt um zu zeigen das die Implementierung der Spezifikation unter allen möglichen Umständen entspricht. MBT erzeugt aus einem Modell systematisch eine Menge von Testfällen, die auch \textit{test suite} genannt wird. Diese Testfälle, wenn sie auf die Implementierung des Systems angewendet werden, bieten ausreichende Überzeugung, dass das \textit{System Under Test} sich so verhält, wie sein Modell es definiert hat. Laut Kicillof \cite{Kicillof2009} ist der Unterschied zwischen leichtgewichtigen und schwergewichtigen formalen Methoden der Unterschied zwischen ausreichender Überzeugung und vollständiger Sicherheit. Allerdings sei der Preis für absolute Sicherheit sehr hoch, da schwergewichtige Methoden benötigt werden, die nur sehr schwierig angewendet werden können. Der leichtgewichtige MBT-Ansatz dagegen, würde laut Kicillof, viel besser skalieren und wurde bereits erfolgreich in großen Projekten, auch innerhalb Microsoft, angewendet.

\section{Anwendung}
Nachdem die theoretischen Grundlagen des modellbasierten Testen erwähnt wurden, beschäftigt sich dieser Abschnitt mit der Anwendung der Methode. Neben vielen Texten im Internet gibt es ein Schriftstück, das besondere Authorität genießt. Margus Veanes, Colin Campbell und Wolfram Schulte haben das Spec Explorer Team bei Microsoft verlassen und zusammen mit Jonathan Jacky ein Buch über modellbasiertes Testen mit C$\#$ veröffentlicht \cite{JonathanJacky2008}. Zu diesem Buch haben besagt vier eine open-source Implementierung eines modellbasierten Test-Werkzeugs namens \textit{NModel} released \cite{Microsoft2008}, welches auf der codeplex-Seite kostenlos heruntergeladen kann. Inwiefern \textit{NModel} die gleichen Funktionen wie Spec Explorer besitzt, konnte im Rahmen dieser Seminararbeit leider nicht näher untersucht werden.

\section{Schwierigkeiten}
\label{sec:schwierigkeiten}
Obwohl die Methode des modellbasierten Testen laut Nico Kicillof \cite{Kicillof2009} wesentlich einfacher und besser anwendbar als andere Verifikationsverfahren sind, bestehen auch hier einige Schwierigkeiten. Wolfgang Grieskamp hat sich in seinem Buch \cite{Grieskamp2006} mit diesen Problemen auseinander gesetzt. In den folgenden Unterabschnitten werden die fünf Probleme näher beschrieben, die die effektive Nutzung der Methode mithilfe eines Werkzeugs besonders schwierig oder umständlich machen.

\subsection{State Explosion}
\label{subsec:stateexplosion}
Wolfgang Grieskamp beschreibt in seinem Buch \cite{Grieskamp2006} und in seinem Blogpost \cite{Grieskamp2009} das Problem, dass in einer Anwendung sehr viele Zustände existieren als \textit{State Explosion}. Die Durchführung einer \textit{State Space Exploration}, also das ermitteln aller Zustände eines Systems, wird insofern erheblich erschwert, da signifikante Zustände einfach nicht mehr in der Fülle von unwichtigen Zuständen erkannt werden können. Weiterhin besteht die Möglichkeit einer unendlich großen Zustandsmenge im Falle der Verwendung einer Listen-artigen Datenstruktur. Eine Operation, die auf einer Liste ausgeführt werden kann, hat für jede Konfiguration der Liste einen Zustand als Vorbedingung. Wenn eine Liste theoretisch unendlich viele Elemente enthalten kann, existieren unendlich viele Vorbedingungen. Ähnlich ist das wenn Objekte dynamisch instantiiert werden. Für jedes neue Objekt existiert eine neue Vorbedingung für jede globale Operation. Dieses Phänomen beschreibt Grieskamp als \textit{State Explosion}, da die Menge der Zustände sprichwörtlich explodiert, also unkontrollierbar groß wird.

\subsection{Spezifikation}
\label{subsec:spezifikation}
Ein weiteres von Wolfgang Grieskamp beschriebenes \cite{Grieskamp2006} Problem besteht in der Art und Weise wie ein Modell spezifiziert wird. In \textit{AsmL-T} wurde ein Modell in \textit{AsmL} spezifiziert und erforderte somit die Kenntnis der Sprache. Für Wissenschaftler ist dies kein Problem, für die Industrie schon. Da ein Modell eine Realität besonders einfach und abstrahiert repräsentieren soll, sollte dieses Modell auch ohne großen Aufwand erstellt werden können. Die Schwierigkeit der Modellerzeugung sollte in der Formalisierung der Anforderungen liegen und nicht in der technischen Übersetzung der Anforderung in eine spezielle Sprache. Je einfacher eine solche Sprache nutzbar ist, desto unwahrscheinlicher ist die Einführung von Fehlern bei der Formalisierung der Anforderungen.

\subsection{Zustände und Szenarien}
\label{subsec:zustaendeszenarien}
In Unterabschnitt \ref{subsec:stateexplosion} wurde die Menge an ermittelten Zuständen bereits erwähnt. Da Zustände in Unterschiedlichen Kontexten auftreten können, ist eine Abstraktion von diesen Zuständen erforderlich, um die Funktion der Implementierung den Zuständen zuordnen zu können. Wolfgang Grieskamp beschreibt \cite{Grieskamp2006} eine Lösung dieses Problem als Szenario-Orientierung. Ein Szenario ist ein Ablauf von verschiedenen Funktionen des Systems. Das System erreicht darin mehrere Zustände in einer Reihenfolge. Ein Beispiel für ein Szenario wäre: Benutzer meldet sich am System an, macht etwas und meldet sich wieder ab. Szenarien können daher auch \textit{User Stories} genannt werden. Laut Grieskamp \cite{Grieskamp2009} unterstützen viele MBT-Werkzeuge nur das Testen der der Zustände der Implementierung, nicht aber das Testen von Szenarien. Er sieht eine Schwierigkeit in der Kombination des Zustandsraums (State Space), der durch die \textit{State Space Exploration} generiert wird, mit den Aktions-orientierten Szenariobeschreibungen. Während \textit{Unit Tests}, wie sie in Abschnitt \ref{sec:testen} beschrieben wurden, Szenarien testen, sollte ein MBT-Ansatz diese Szenarien ebenfalls testen können um eine vergleichbare Testgranularität gewährleisten zu können.

\subsection{IDE Unterstützung}
\label{subsec:ideunterstuezung}
Wolfgang Grieskamp identifiziert in seinem Blogpost \cite{Grieskamp2009} die mangelnde Integration in Entwicklungswerkzeuge als weiteres Problem. Viele formale Verifikationsverfahren nutzen spezielle Programm, die Wissenschaftler bedienen können, Entwickler dagegen in der Regel nicht verstehen. Wenn die Methode des modellbasierten Testen an Beliebtheit und Bekanntheit zunehmen soll, muss eine Umgebung genutzt werden, in der sich die Entwickler auskennen. Es kann allgemein als unrealistisch angesehen werden, dass ein Entwickler eine neue Umgebung erlernen wird, wenn er nur eine indirekte  Produktivitätssteigerung des sowieso unbeliebten Testen erreichen kann. Im Gegensatz ist eine Testumgebung, mit der der Entwickler bereits vertraut ist, die ideale Voraussetzung. Die zu testende Implementierung, das Modell und die Verifikation sollte laut Grieskamp über eine einheitliche Benutzerschnittstelle erreichbar sein. Da die IDE (Integrated Development Environment) bereits für die Implementierung des Systems genutzt wird, liegt eine Integration des MBT-Werkzeugs in dieses Programm nahe.

\subsection{Testfallerzeugung}
\label{subsec:testfallerzeugung}
Wenn MBT-Werkzeuge eine Implementierung anhand eines Modells verifizieren, dann sollte der Prozess der Verifikation ebenfalls von einem Test Runner durchgeführt werden können, der auch \textit{normale} Tests durchführen kann. Wolfgang Grieskamp sieht in der fehlenden Unterstützung für Test Runner ein weiteres Problem \cite{Grieskamp2009} des MBT-Ansatzes. Die Verifikation anhand eines Modells sollte  ohne hohe Laufzeitkosten durchgeführt werden können, also ohne jedes mal eine \textit{State Space Exploration} durchführen zu müssen. Besonders vor dem Hintergrund von Continuous Integration ist eine automatische Verifikation als Teil eines automatisierten Buildvorgangs durchaus denkbar. Der Schritt des Testen der Implementierung sollte laut Grieskamp so allgemein wie möglich durchgeführt werden können und zwar auf eine Weise, die dem traditionellen Testen mit \textit{Unit Tests} sehr ähnlich ist. Eine Erzeugung der Testfälle für ein bekanntes Testing Framework würde das modellbasierte Testen, zumindest was den Schritt der Verifikation angeht, erheblich erleichtern.

\chapter{Spec Explorer 2010}
Die aktuelle Version heißt Spec Explorer 2010. Ein erster Prototyp des Werkzeugs, dessen Funktionen dem heutigem Funktionsumfang annähernd entsprechen, wurde bereits 2006 veröffentlicht. Nachdem in dem vorigen Kapitel \ref{chap:mbt} die Idee des modellbasierten Testen beschrieben und auf deren Schwierigkeiten in der Anwendung eingegangen wurde, wird dieses Kapitel die Visual Studio Erweiterung Spec Explorer vorstellen. Dabei wird zunächst gezeigt, wie Spec Explorer die in Abschnitt \ref{sec:schwierigkeiten} vorgestellten Schwierigkeiten versucht zu lösen. Die Punkte, die im Folgenden als Lösungen beschrieben werden, sind aus der Evaluierung des Werkzeugs hervorgegangen.

\section{Die Lösung}
In diesem Abschnitt wird beschrieben, wie Spec Explorer die in Abschnitt \ref{sec:schwierigkeiten} beschriebenen Schwierigkeiten bei der Verwendung eines MBT-Werkzeugs adressiert.

\subsection{State Explosion}
\label{subsec:loesungstateexplosion}
Das in Unterabschnitt \ref{subsec:stateexplosion} beschriebene Problem, dass der Zustandsraum sehr groß wird löst Spec Explorer dadruch Abbruchgrenzen. So ist es möglich den Zustandsraum nur für eine definierte Anzahl an Interation zu explorieren. Weiterhin lassen sich auch Abbruchbedingungen als sogenannte \textit{Bounds} definieren, die Zustände ab einer definierten Entfernung vom Startzustand ignorieren. Was Konfigurationsmöglichkeiten betrifft nutzt Spec Explorer sogenannte \textit{configs} und \textit{machines}, welche in einer Konfigurationsdatei definiert werden. Diese Konfiguration wird über eine Scriptsprache zur Koordination realisiert, die \textit{CORD} genannt wird.
\\
Über \textit{configs} können Einstellungen wie beispielsweise Abbruchbedingungen für die Exploration definiert werden. Weiterhin können auch die Methoden des Modells, die für die Exploration von Bedeutung sind, mit einem Wertebereich für Parameter versehen werden um spezielle Parameterkombinationen zu erzeugen. Diese Methoden werden von Spec Explorer genutzt um das Modell zu explorieren und somit alle Zustände des Modells zu erreichen. Dabei werden die Parameterkombinationen berücksichtigt.
\\
Über \textit{machines} kann die Benutzbarkeit des Modells definiert werden. In Abschnitt \ref{sec:explorationmanager} wird der Exploration Manager vorgestellt. In diesem Manager, der die Interaktion des Benutzers mit dem Tool ermöglicht, werden alle \textit{machines} aufgelistet. Eine \textit{machine} könnte zum Beispiel die Exploration des Modells repräsentieren. Eine weitere \textit{machine} könnte den Zustandsraum mit Szenarien, die ebenfalls als \textit{machine} definiert werden können, verbinden. Auch die Testfallerzeugung wir mit einer \textit{machine} beschrieben.

\subsection{Spezifikation}
Spec Explorer löst die Schwierigkeit des in Unterabschnitt \ref{subsec:spezifikation} als Modellspezifikation beschrieben Problem auf eine sehr einfache Art. Die formale Spezifikation des Modells, das  die Implementierung repräsentieren soll, kann mithilfe der .NET Sprache C$\#$ vorgenommen. Dadurch brauch der Entwickler keine neue Syntax lernen und kann sich auf die Übersetzung von Anforderungen in ein C$\#$-Modell konzentrieren. Unterstützung für andere .NET Sprachen als Modellsprache konnte im Rahmen der Evaluierung nicht festgestellt werden. 

\subsection{Zustände und Szenarien}
\label{subsec:loesungszenarien}
In Unterabschnitt \ref{subsec:zustaendeszenarien} wurde das Problem beschrieben, dass Funktionen, wie Abschnitt \ref{sec:testen} vorgestellt, als Szenarien getestet werden. Erst durch ein erfolgreich getestetes Szenario kann davon ausgegangen werden, dass ein Feature der Anwendung funktioniert. Ein Szenario ist, wie bereits erwähnt, eine Abfolge von Benutzer-Aktionen: Einloggen, Bestellen, Ausloggen wäre ein Beispiel. Spec Explorer erlaubt es, Szenarien als \textit{machines} zu definieren. Dazu wird eine \textit{CORD}-Syntax verwendet, die sehr stark an reguläre Ausdrücke erinnert, um Aktionen, die im Modell als solche gekennzeichnet werden, in definierter Reihenfolge aufzurufen. Welche Möglichkeiten diese Ausdrucksweise bietet, konnte in dieser Seminararbeit leider nicht weiter analysiert werden.
\\
Wird die \textit{machine} eines Szenarios über den Exploration Manager aufgerufen, wird das Modell anhand des Szenarios ebenfalls exploriert und als Zustandsdiagramm dargestellt. Dabei nimmt das Modell pro Aktion einen Zustandswechsel vor, sodass mehrere Zustände erreicht werden. In einer weiteren \textit{machine} können die Zustände, die durch ein Szenario erreicht werden, aus der Zustandsraum-Exploration heraus geschnitten werden. Spec Explorer spricht hier von \textit{slicing}. Das Ergebnis dieser parallelen Ausführung der Explorations-Maschine und der Szenario-Maschine kann ebenfalls als Zustandsdiagramm dargestellt werden. Hier werden dann alle Zustände angezeigt, die durch Aufrufe der Aktionen des Modells mit konkreten Werten im Rahmen eines Szenarios erreicht werden. Es entsteht also ein Zustandsautomat, der ein Szenario, also die Features einer User Story, repräsentiert. Aus dieser kombinierten \textit{machine} werden später auch die Testfälle für dieses Feature erzeugt.

\subsection{IDE Unterstützung}
In Unterabschnitt \ref{subsec:ideunterstuezung} wurde mangelnde Unterstützung für Entwicklungsumgebungen als Problem klassifiziert. Spec Explorer ist eine Visual Studio 2010 Erweiterung und damit in die IDE von Microsoft integriert. In Kapitel \ref{chap:vsintegration} wird konkret gezeigt, wie diese Integration aussieht. Unterstützung für andere Entwicklungsumgebungen ist nicht vorhanden. Da Erweiterungen für Visual Studio 2010 erst ab der Professional Edition installiert werden können, ist Spec Explorer leider auch nicht für die Visual Studio Express Editionen verfügbar.

\subsection{Testfallerzeugung}
Das Funktionen der Anwendung Szenario-orientiert getestet werden, wurde bereits in Abschnitt \ref{sec:testen} erwähnt. Wie Szenarien mit Spec Explorer im Rahmen der Zustandsraum-Exploration verwendet werden können, wurde in Unterabschnitt \ref{subsec:loesungszenarien} beschrieben. Spec Explorer nutzt das standardmäßig mit Visual Studio 2010 Professional ausgelieferte Test Framework (\textit{Microsoft.VisualStudio.TestTools.UnitTesting}) sowie dessen Integration \textit{MS Test}. Damit laufen die von Spec Explorer erzeugten Testfälle im Test Runner von Visual Studio. Unterstützung für andere Test Frameworks konnte leider nicht festgestellt werden.
\\
Testfälle werden durch eine \textit{machine} erzeugt, die den Zustandsautomaten eines Szenarios in einzelne lineare Abläufe von Aktionen aufteilt. Aus einem Szenario werden so mehrere isolierte Abläufe, die in dem Automaten parallel existieren. Die erzeugten Tests sind sehr überladen und erhalten neben den Aufrufen der Aktionen der Implementierung, die durch das Modell festgelegt wurden, eine Menge an Kommentaren, die den Testfall unleserlich machen. Da die erzeugten Tests jederzeit neu aus der entsprechenden \textit{machine} erzeugt werden können, ist eine manuelle Änderung nicht vorgesehen.
\\ 
Bei der Testfallerzeugung kommt zum ersten mal die Implementierung zum Tragen. Während die Zustände und Szenarien über dem Modell definiert werden, nutzen die erzeugten Tests die Implementierung. Die Tests rufen die über Aktionen auf dem Modell definierten Methoden der Implementierung auf, und vergleichen anschließend den Zustand der Implementierung mit dem Zustand den das Modell in gleichem Kontext hatte. Der Test schließt erfolgreich ab, wenn die Implementierung der gleichen Zustand besitzt wie das Modell. Der Test schlägt fehl, wenn die Zustände nicht identisch sind. Also wird die in Kapitel \ref{chap:mbt} beschriebene Verifikation der Implementierung anhand der durch das Modell spezifizierten Zustände über die erzeugten Testfälle vorgenommen. Die Verifikation könnte dank der erzeugten Testfälle auch ausgelagert werden und beispielsweise automatisch durchgeführt werden, sobald ein neuer Build der Implementierung entsteht. Die Testfälle müssen erst neu erzeugt werden, wenn sich die Anforderungen und damit das Modell der Software ändern.

\section{Umgebung}
Abbildung \ref{fig:seworkflow} illustriert den Ablauf des Testens mit Spec Explorer. Dabei werden unter anderem die drei Bestandteile der Umgebung dargestellt (die Implementierung, das Modell und die erzeugten Testfälle) und in wie diese zusammenhängen.

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{seworkflow.png}
\caption{Schematische Darstellung des Arbeitsablaufs bei der Verwendung von Spec Explorer}
\label{fig:seworkflow}
\end{figure}

In der semantischen Darstellung wird davon ausgegangen, dass bereits eine Implementierung besteht, die anhand eines ebenfalls bestehenden Modells verifiziert wird. Selbstverständlich könnte auch nur ein Modell existieren und die Implementierung würde erst nach der Testfallerzeugung im Rahmen eines \textit{Test First}-Ansatzes entstehen. Ebenfalls kann eine bestehende Implementierung auch nachträglich getestet werden, indem das Modell nachträglich entsteht. Eine gute Spezifikation entsteht jedenfalls dann, wenn Modell und Implementierung möglichst unabhängig voneinander entstehen.
\\
In diesem Abschnitt werden die Zusammenhänge von Implementierung, Modell und Konfiguration des Modells beschrieben. 

\subsection{Implementierung}
Der erste Teil einer Spec Explorer Umgebung besteht aus der Implementierung. In Abbildung \ref{fig:seimplementation1} ist rechts die Umgebung zu sehen, die durch \textit{File/New Project/Spec Explorer Project} erstellt wird. Die Visual Studio Solution enthält drei Projekte. Das erste Projekt ist das Modell-Projekt und enthält neben der Klasse \emph{AccumulatorModelProgram} die Konfiguration \emph{Config.cord}. Das zweite Projekt ist das Implementierung-Projekt und enthält nur die Klasse \emph{Accumulator}. Das letzte Projekt ist ein \textit{MS Test}-Projekt, dass die erzeugten Testfälle enthält. Da das Test-Projekt aus dem Modell-Projekt entsteht, wird dieses Projekt an dieser Stelle nicht weiter behandelt.

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{seimplementation1.png}
\caption{Fehlerhafte Implementierung}
\label{fig:seimplementation1}
\end{figure}

Die erwähnte Projektstruktur ist typisch für ein Spec Explorer Projekt, auch wenn die im Beispiel erwähnten Klassen dem Sample entsprechen, das Spec Explorer automatisch erzeugt wenn ein Projekt erstellt wird. In einer produktiven Umgebung würden die erstellten Klassen entfernt und durch eigene ersetzt werden. Natürlich kann ein Spec Explorer Projekt auch nachträglich aus einem bereits existierenden Projekt erzeugt werden, indem ein Modell- und Test-Projekt angelegt werden, aber dieser Fall wird im Folgenden nicht weiter betrachtet.
\\
Die in Abbildung \ref{fig:seimplementation1} dargestellte Klasse \emph{Accumulator} ist Teil Implementierung. Offensichtlich ist die dargestellte Implementierung fehlerhaft. Auch wenn dieses Beispiel sehr trivial erscheint, werden die Eigenschaften von Spec Explorer sowie der entsprechende Arbeitsablauf an diesem Beispiel sehr gut deutlich. Die Absicht der Implementierung in diesem Fall soll Ganzzahlen aufaddieren und zurückgeben können. Beim Zurückgeben sollen die aufsummierten Zahlen wieder auf 0 gesetzt werden. Dieses Verhalten soll durch ein Modell verifiziert werden können.

\subsection{Modell}
\label{subsec:umgebungmodell}
Das zweite Projekt in der Spec Explorer Solution enthält das Modell. Spec Explorer unterstzt zwei Modell-Typen. Zum einen das statische Modell und zum anderen das nicht-statische Modell. Das statische Modell ist eine statische Klasse, dessen Aktionen ebenfalls nur statisch sind. Dadurch brauch sich Spec Explorer bei der Zustandsraum Exploration nicht um Instanzen kümmern. Das nicht-statische Modell verwendet Methoden von Objekten als Aktionen während der Exploration. Dadurch können unterschiedliche Zustände entstehen, je nachdem auf welchem Modell-Objekt eine Aktion ausgeführt wird. In dieser Seminararbeit wird ausschließlich der statische Ansatz behandelt. Das bedeutet nicht, dass das statische Modell keine Objekte verwenden kann, sondern lediglich die Aktionen müssen statisch bleiben. Dieser Ansatz hat also nur ein einziges Objekt-Kontext und das ist die Klasse selber.

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{semodel.png}
\caption{Das Modell der Implementierung}
\label{fig:semodel}
\end{figure}

In Abbildung \ref{fig:semodel} ist der Quellcode des Modells des Aufsummierers dargestellt. Methoden, die als Aktionen unterschiedliche Zustände während der Exploration erzeugen, werden als Regel definiert, indem ein \emph{Rule}-Attribut zur Dekoration der Methode verwendet wird. In diesem Attribut wird auch die Methode der Implementierung spezifiziert, die der Zustandsänderung entspricht. Dies ist notwendig, da die erzeugten Testfälle genau diese Methode nutzen sollen, um die erwartete Zustandsänderung der Implementierung herbeizuführen und anschließend zu verifizieren. Die Methodensignaturen müssen kompatibel sein.
\\
Die Regeln des Modells entsprechen einer sehr einfachen Realisierung der Implementierung. Das Modell einer Datenbank könnte beispielsweise eine Hashtable als Datenstruktur verwenden. Das Modell in diesem Summen-Beispiel ist mit der Implementierung fast identisch, was an der Trivialität des Beispiels liegt. Weiterhin können \textit{Code Contracts}, die bereits aus Abschnitt \ref{subsec:specsharp} über \textit{Spec$\#$} bekannt sind. Im Beispiel enthält jede Regel des Modells eine Pre-Condition und zwar wird dadurch sichergestellt, dass das Modell nur positive Zahlen, die größer als Null sind, aufaddiert. Dadurch wird die Zustandsraum-Exploration eingeschränkt um dem Problem der Zustandsraum-Explosion aus Unterabschnitt \ref{subsec:stateexplosion} entgegengewirkt, da nur Aufrufe dieser Aktion nur neue Zustände erzeugen, wenn die Vorbedingungen gelten.

\subsection{Konfiguration}
\label{subsec:umgebungkonfiguration}
Das zweite Projekt einer Spec Explorer Solution enthält neben dem Modell auch eine Konfiguration. Diese Konfiguration besteht aus den in Unterabschnitt \ref{subsec:loesungstateexplosion} bereits vorgestellten \textit{configs} und \textit{machines}. Abbildung \ref{fig:seconfig1} zeigt die beiden \textit{configs} der Konfiguration des Summen-Beispiels. Die \emph{Main}-\textit{config} nimmt über \textit{switches} allgemeingültige Einstellungen der Explorationen der \textit{machines} vor. Unter anderem wird in dem Beispiel der Pfad zu dem Test-Projekt festgelegt, in dem die Testfälle erzeugt werden sollen. Eine maximale Aktions-Tiefe für Aufrufe der Modellregeln wird ebenfalls festgelegt. Die wichtigste Einstellung ist allerdings die Definition der Regeln der Modells als Aktionen (\textit{actions}).

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{seconfig1.png}
\caption{Die Konfiguration der Modellexploration}
\label{fig:seconfig1}
\end{figure}

Die \emph{ParameterCombination}-\textit{config} stellt eine Parameterkombination dar, wie sie bereits in Unterabschnitt \ref{subsec:loesungstateexplosion} beschrieben wurde. Diese Kombination ist eine Erweiterung für die \emph{Main}-\textit{config}, was durch die Notation der Vererbung ausgedrückt wird. Die Aktion \emph{Accumulator.Add(int x)} wird im Beispiel eingeschränkt, sodass der Wert für \emph{x} aus dem Intervall \emph{[0..2]} gewählt wird. Dies ist eine weitere Möglichkeit die Zustandsraum-Explosion aus Unterabschnitt \ref{subsec:stateexplosion} in den Griff zu bekommen.
\\
Die Konfiguration besteht ebenfalls aus \textit{machines}. Abbildung \ref{fig:seconfig2} zeigt die Definition von vier Maschinen. Die \emph{AccumulatorModelProgram}-\textit{machine} nutzt die \emph{Main}-\textit{config} und erlaubt die Exploration. Der komplette Zustandsraum wird unter Verwendung der in \emph{ParameterCombination}-\textit{config} definierten Parameterkombination exploriert.
Die \emph{DoubleAddScenario}-\textit{machine} definiert ein Szenario, wie es in Unterabschnitt \ref{subsec:loesungszenarien} vorgestellt wurde. Diese Maschine erlaubt ebenfalls die Exploration, allerdings nicht die des Zustandsraums des Modells. Lediglich die Zustände des Szenarios, also ohne Werte des Modells mit einzubeziehen, werden exploriert. Die Syntax der Definition der Regel-Aufrufe ((\emph{Add}, \emph{Add}, \emph{ReadAndReset}) beliebig oft und mit beliebigen Werten) ähnelt der Syntax von regulären Ausdrücken.

\begin{figure}[htbp]
\centering
\includegraphics[width=400px]{seconfig2.png}
\caption{Die Konfiguration der Modell-Maschinen}
\label{fig:seconfig2}
\end{figure}

Die \emph{SlicedAccumulatorModelProgram}-\textit{machine} lässt sich ebenfalls explorieren und verbindet den Zustandsraum mit dem Szenario. Die Notation der Verbindung über den \textdoublevertline
 -Operator lässt beide Maschinen parallel ausführen. Das Ergebnis ist also die Exploration des Zustandsraums des Szenarios, unter Berücksichtigung der Zustände des Modells. Es werden also alle möglichen Zustände gefunden, die das Modell haben kann, im Rahmen des Szenarios. Die \emph{AccumulatorTestSuite}-\textit{machine} ist ebenfalls explorierbar und kann Testfälle erzeugen. Dafür nutzt diese Maschine das Explorationsergebnis der \emph{SlicedAccumulatorModelProgram}-\textit{machine}. Wenn diese Maschine exploriert wird, werden die zusammenhängenden Zustandsübergänge der Exploration des Szenarios aufgesplittet, sodass konkrete Durchläufe des Szenarios mit speziellen Werten entstehen. Aus der Exploration werden also wieder getrennte Aufruf-Ketten von Aktionen bestimmt, aus denen anschließend kurze Testfälle erzeugt werden können. 

\section{Exploration}
Eine in der Konfiguration definierte \textit{machine} kann exploriert werden. Abbildung \ref{fig:seexploration} zeigt die Zustandsraum-Exploration des Modells. Der Zustandsautomat wird von Spec Explorer automatisch gezeichnet und erlaubt panning und zooming, sowie die Auswahl von Zuständen und Zustandsübergänge. Dabei werden für die von Spec Explorer automatisch nummerierten Zustände weitere Eigenschaften, wie beispielsweise der aktuelle Wert der Modell-Veränderlichen, angezeigt.

\begin{figure}[htbp]
\centering
\includegraphics[width=380px]{seexploration.png}
\caption{Darstellung der Exploration des Modells als Zustandsautomat}
\label{fig:seexploration}
\end{figure}

Aus Abbildung \ref{fig:seexploration} geht ebenfalls hervor, dass die Exploration nicht unendlich ist. Die gelb eingefärbten Zustände markieren die Abbruchgrenze des Zustandsraums. Bei diesen gelben Zuständen ist die Grenze von 5 Bounds erreicht, sodass die Exploration abbricht. Bounds lassen sich über \textit{configs} in der Konfiguration einstellen.

\section{Szenarien}
Szenarien wurden bereits in Unterabschnitt \ref{subsec:loesungszenarien} behandelt. Dort wurde erklärt, wie Spec Explorer Szenarien als \textit{machines} definieren kann, die ebenfalls exploriert werden können. In Abbildung \ref{fig:sescenario} ist die Exploration des (\emph{Add}, \emph{Add}, \emph{ReadAndReset})-Szenarios dargestellt. Der Zustandsautomat des Ergebnisses ist sehr anschaulich und entspricht dem Verhalten, dass man auch von der Implementierung erwarten würde.

\begin{figure}[htbp]
\centering
\includegraphics[width=250px]{sescenario.png}
\caption{Darstellung eines Szenarios als Zustandsautomat}
\label{fig:sescenario}
\end{figure}

In Abbildung \ref{fig:seslicedscenario1} ist die Exploration der \textit{machine} zu sehen, die die Zustände des Szenarios aus dem kompletten Zustandsraum des Modells herausschneidet.

\begin{figure}[htbp]
\centering
\includegraphics[width=260px]{seslicedscenario1.png}
\caption{Darstellung eines Szenarios in Verbindung mit der Zustandsraum-Exploration}
\label{fig:seslicedscenario1}
\end{figure}

Das Ergebnis entspricht einem Zustandsautomaten, der das Szenario komplett abbildet. Alle Zustände, die das Modell in Bezug auf das Szenario haben kann, werden erreicht. Um das Szenario an der Implementierung zu testen, müssen jetzt lediglich die Aufrufe, die für die Zustandsübergänge von dem Startzustand \emph{S0} über andere Zustände hinweg zurück zum Startzustand führen, als getrennte Aufruf-Ketten interpretiert werden.

\section{Testfälle}
Die getrennten Aufruf-Ketten, die für die Testfälle erforderlich sind, werden, wie in Unterabschnitt \ref{subsec:umgebungkonfiguration} beschrieben, über eine weitere \textit{machine} definiert. Abbildung \ref{fig:seslicedscenario2} zeigt die Exploration aller gültigen Pfade durch den Zustandsautomaten des Szenarios aus Abbildung \ref{fig:seslicedscenario1}. Die von der Maschine verwendete Strategie \emph{ShortTests} ist für die Auftrennung der Pfade verantwortlich. Auf weitere Strategien wird in dieser Seminararbeit nicht eingegangen.

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{seslicedscenario2.png}
\caption{Darstellung aller testbaren Ausprägungen eines Szenarios}
\label{fig:seslicedscenario2}
\end{figure}

Diese Aufruf-Ketten können jetzt von Spec Explorer eins zu eins in Testfälle übersetzt werden. Der Exploration Manager unterstützt die Testerzeugung einer Maschine, die mit \emph{TestEnabled = true} definiert ist. Auffällig ist hier die Syntax, die sich sehr an die menschliche Sprache anlehnt.
\\
Spec Explorer erzeugt für jede Ablauf-Kette einen Testfall (\emph{TestMethodAttribute}) in der Test-Klasse (\emph{TestClassAttribute}) des Szenarios. Die erzeugten Tests haben eine Abhängigkeit von der Spec Explorer Runtime Testumgebung. Theoretisch könnten die Tests auch ohne diese Abhängigkeit funktionieren. Durch diese Referenz haben die Tests die Möglichkeit Timeouts zu setzen, sowie die Ausführung detailliert zu protokollieren. Abbildung \ref{fig:setestcode1} zeigt die Test-Klasse, während die Testfälle für die vier Aufruf-Ketten zugeklappt sind.

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{setestcode1.png}
\caption{Codeausschnitt eines erzeugten Testfalls}
\label{fig:setestcode1}
\end{figure}

Abbildung \ref{fig:setestcode2} zeigt den erzeugten Testfall exemplarisch für die Aufruf-Kette (\emph{Add(2)}, \emph{Add(2)}, \emph{ReadAndReset()/4}). Der Test ruft die Methoden der Implementierung (!) auf, die mit den Regeln des Modells verknüpft wurden (wie Unterabschnitt \ref{subsec:umgebungmodell} beschrieben) und vergleicht abschließend ob der Rückgabewert der \emph{ReadAndReset}-Aktion dem erwarteten Wert \textit{4} entspricht.

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{setestcode2.png}
\caption{Codeausschnitt einer Test-Methode im erzeugten Testfall}
\label{fig:setestcode2}
\end{figure}

Die Tests sind sofort mit den Testwerkzeugen in Visual Studio 2010 ab Professional ausführbar. Erwartungsgemäß schlagen alle Tests fehl, dessen Erwartungswert ungleich \textit{4} ist.
\newpage
Dank der umfangreichen Protokollierung der Testfälle, ist die Beschreibung eines fehlgeschlagenen Tests sehr aussagekräftig und hilfreich. Der Entwickler sieht sofort, inwiefern sich der erwartete Zustand vom tatsächlichen unterscheidet, und zwar direkt auf die Variablen der Implementierung bezogen. Damit ist die Testerzeugung aus dem Modell komplett von Spec Explorer übernommen worden. Das Ergebnisse sind hilfreiche Testfälle, die noch nicht einmal programmiert werden mussten.
\\
Abbildung \ref{fig:seimplementation2} zeigt eine korrigierte Version der in Abbildung \ref{fig:seimplementation1} gezeigten fehlerhaften Implementierung. Diese Implementierung entspricht der einfachsten Version einer Summen-Funktion und funktioniert, was durch das erfolgreiche Durchlaufen aller vier Testfälle impliziert wird.

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{seimplementation2.png}
\caption{Korrigierte Implementierung}
\label{fig:seimplementation2}
\end{figure}

Damit endet die Evaluierung der Funktionsweise der Visual Stuido Erweiterung Spec Explorer 2010. Es wurde beschrieben, welche Projekt-Komponenten eine Spec Explorer Solution beinhaltet und wie diese zusammenhängen. Dabei wurde auf die Bedeutung der Konfiguration von Maschinen eingegangen und wie aus diesem Maschinen das Modell aus unterschiedlichsten Perspektiven im Rahmen von Szenarien exploriert werden kann. Weiterhin wurde gezeigt, wie Testfälle erzeugt werden können, die das zustandsorientierte Verhalten der Implementierung mit den Zuständen des Modells vergleichen. Von diesem Standpunkt aus, kann mit einer hohen Wahrscheinlichkeit von der Korrektheit der Implementierung ausgegangen werden. Im Gegensatz zu allen anderen Test-Methoden führt eine Veränderung der Spezifikation nur zu einer kleinen Änderung des Modells. Alle Testfälle können anschließend automatisch neu erzeugt werden.



\chapter{Visual Studio Integration}
\label{chap:vsintegration}
In diesem Kapitel wird auf die Integration der Spec Explorer Erweiterung mit Visual Studio eingegangen. Die Erweiterung installiert ein neues Projekt-Template unter \textit{File/New Project} und ein neues Fenster, den Exploration Explorer.

\section{Exploration Manager}
Der Exploration Manager ist ein Fenster, das sich in Visual Studio wie jedes andere Fenster wie eine Toolbox beliebig andocken lässt. Es enthält eine Auflistung aller in der Konfiguration beschriebenen \textit{machines}, die in Unterabschnitt \ref{subsec:umgebungkonfiguration} vorgestellt wurden. Jede dieser Maschinen kann über das Kontext-Menü exploriert werden, sofern die Maschine Exploration nicht unterdrückt. Aus einer \textit{machine}, die \emph{TestEnabled = true} definiert, können Testfälle erzeugt, die anschließend im Test-Projekt gespeichert oder einfach nur ausgeführt werden. Abbildung \ref{fig:seexplorationmanager} zeigt den Screenshot der Auflistung der Maschinen sowie das Kontext-Menü.

\begin{figure}[htbp]
\centering
\includegraphics[width=300px]{seexplorationexplorer.png}
\caption{Screenshot des Exploration Manager Fensters in Visual Studio 2010}
\label{fig:seexplorationmanager}
\end{figure}

\label{sec:explorationmanager}

\section{UML Extensions}
Eine Erweiterung für Spec Explorer ist die Visual Studio Erweiterung \textit{UML Extensions} \cite{Microsoft2011}. Diese Extension erlaubt es aus einem explorierten Szenario ein UML-Sequenzdiagramm zu erzeugen. Aus diesem Sequenzdiagramm sind die konkreten Abläufe, die im Rahmen des Modells stattfinden, deutlich besser nachzuvollziehen und erlauben eine bessere Abbildung der Exploration auf den Quellcode des Modells. Leider kann im Rahmen dieser Seminararbeit nicht näher auf diese Erweiterung eingegangen werden.



\chapter{Einsatz bei Microsoft}
In diesem Kapitel wird auf die Verwendung des Tools innerhalb Microsofts eingegangen. Leider konnten keine Information über die Verwendung durch andere Einrichtungen gefunden werden, sodass die Microsoft für diesen Akzeptanzbericht gewählt wurde.
\\
Wolfgang Grieskamp beschreib in seinem Blogpost \cite{Grieskamp2009}, dass das Spec Explorer Team seit 2007 in der Windows Server Division angesiedelt ist. Das ist dadurch zu erklären, dass diese Abteilung viele eigene und standardisierte Protokolle einsetzt, die effektiv und effizient getestet werden müssen. Im Rahmen der "`Microsoft Open Specifications"' Bewegung \cite{Microsoft2011a} hat Microsoft begonnen sämtliche in Windows enthaltene Protokolle ausführlich schriftlich zu spezifizieren und zu testen. Dies hatte eine enge Zusammenarbeit mit dem Spec Explorer Team zur Folge, was zu dem Umzug des Team geführt hat. Mittlerweile gibt es neben dem Team in Redmond auch ein Spec Explorer Team in Peking, China, das sich mit der Entwicklung und dem Testen von Spec Explorer beschäftigt.
\\
Wolfgang Grieskamp hat zusammen mit Nico Kicillof und weiteren Spec Explorer Experten eine Ausarbeitung geschrieben, die sich mit dem modellbasierten Qualitätssicherung der \textit{Windows Protocol Documentation} auseinandersetzt \cite{WolfgangGrieskamp2008}.
\\
In seinem Blogpost \cite{Grieskamp2009} beschreibt Wolfgang Grieskamp die erfolgreiche Nutzung von Spex Explorer in einem Großprojekt mit einem Testaufwand von insgesamt 250 Mann-Jahren. Dabei geht nicht hervor, ob es sich bei diesem Projekt um die "`Microsoft Open Specifications"' Bewegung handelt. Jedenfalls wurden im Rahmen dieses Großprojekts die beteiligten Teams vor die Wahl gestellt ein modellbasiertes Test-Werkzeug, höchst wahrscheinlich Spec Explorer, oder einen traditionellen Test-Ansatz zu nutzen. Angeblich haben sich laut Grieskamp 50\% für das modellbasierte Tool und 50\% für traditionelles Unit-Testing entschieden. Zusammenfassend bescheinigt Grieskamp den Teams, die das modellbasierte Test-Tool eingesetzt haben, eine Effizientsteigierung von durchschnittlich 42\% nach einem Einsatz von 2,5 Jahren. Diese Steigerung wurde durch testunerfahrenes Personal erreicht und nicht, wie vielleicht vermutbar wäre, durch testerfahre Mitarbeiter. In welchem Zusammenhand diese Steigerung steht, erklärt Grieskamp leider nich. Es kann aber davon ausgegangen werden, dass die 42\% im Vergleich zu den anderen Team, die das modellbasierte Tool nicht eingesetzt haben, verstanden werden können.



\chapter{Fazit}
Nachdem in den vorigen Kapiteln die Visual Studio Erweiterung Spec Explorer, sowie Grundlagen und Entwicklung beschrieben wurden, fasst dieses Kapitel die wichtigsten Gegenstände, die Spec Explorer besonders auszeichnen, zusammen.
\\\\
Spec Explorer ist ein Test-Werkzeug, das es erlaubt Testfälle für eine Implementierung automatisch zu erzeugen. Diese Testfälle werden aus einem Modell, das die Implementierung repräsentiert, abgeleitet. In dem Modell werden die Anforderungen an die Software in C$\#$ spezifiziert. Dabei bleibt das Modell abstrakt und formal. Spec Explorer kann dieses Modell lesen und versucht alle Zustände, die das Modell haben kann, durch Ausführen von Regeln, die den Zustand des Modells verändern, zu erreichen. Es entsteht die sogenannte Zustandsraum-Exploration.
\\
Auf diesem Zustandsraum lassen sich Zustände als Szenarien, die durch Aufruf-Ketten von Regeln definiert werden, zusammenfassen. Durch die Verbindung von Zustandsraum und Szenario lassen sich alle Zustände des Modells finden, die durch das Szenario entstehen können. Aus diesen Zuständen können die als Szenario definierten Aufruf-Ketten als Pfade auftrennen. Ein Pfad entspricht also einer mit konkreten Werten verbunden Aufruf-Kette von Regeln und erreicht bestimmte Zustände.
\\
Aus einer solchen Ablauf-Kette kann ein Testfall erzeugt werden. Durch die Reihenfolge der Regel-Aufrufe können die entsprechenden Methoden des Modells aufgerufen werden. Der Zustand, den das Modell nach Ablauf der Aufruf-Kette hat, wird mit dem Zustand verglichen, den die Implementierung nach Aufruf der Methoden hat. Ein solcher Testfall wird von Spec Explorer für  \textit{MS Test} erzeugt und kann somit direkt durch Visual Studio ausgeführt werden.
\\
Spec Explorer testet also ob die Implementierung die gleichen Zustände erreicht wie das Modell, wenn die gleichen Regeln oder Methoden zur Veränderung der Veränderlichen des Systems, beziehungsweise des Modells, ausgeführt werden. Diese Art von Testfall kann auch als State-based Testen bezeichnet werden. Das bedeutet auch, das Spec Explorer nicht die Struktur oder die Interaktion des Systems testet.
\\\\
Abschließend kann Spec Explorer als modellbasiertes Test-Werkzeug zusammengefasst werden, das die Zustände einer Implementierung anhand der Zustände einer Spezifikation verifizieren kann.



\bibliography{SpecExplorer}
\bibliographystyle{alpha}

\end{document}
